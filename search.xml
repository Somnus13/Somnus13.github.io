<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原型、原型链笔记]]></title>
    <url>%2F2018%2F12%2F31%2Fprototype-chain%2F</url>
    <content type="text"><![CDATA[解释：为了共享多个对象间的一些共有特征（属性或方法） JavaScript 中的对象，都存在一个内置属性[[prototype]]也做 __proto__，指向这个对象的原型对象 js 中查找一个属性或方法，如果当前对象无定义会继续查找当前对象的原型对象，如果仍未找到，会继续查找原型对象的原型。如此直至最顶层的原型对象，如果仍未找到返回 undefined 最顶层的原型对象 为 Object.prototype, 里面保存了最常用的 toString、valueOf、hasOwnProperty 等方法，故任何对象都可以开箱即用。 创建对象的三种方式1. 字面量方式字面量方式创建对象，它的原型就是 Object.prototype 12var obj = &#123;&#125;;obj.__proto__ === Object.prototype // true 2. 函数构造调用Js 在定义一个函数时，同时为这个函数定义了一个默认的 prototype 属性, 所有的共享的属性或方法都被放到这个属性指向的对象中。 由此看出，通过一个函数的构造调用创建的对象，它的原型就是这个函数的 prototype 属性指向的对象 123456789101112131415161718192021// 创建构造函数function Person(name) &#123; this.name = name;&#125;// 每个构造函数，js 都会为之自动添加一个 prototype 属性，称之为原型，是一个对象// 每个构造函数创建的对象都会共享 prototype 上面的属性与方法console.log(typeof Person.prototype); // 'object'// 为 Person 添加 sayName 方法Person.prototype.sayName = function() &#123; console.log(this.name);&#125;// 创建实例var person1 = new Person('a');var person2 = new Person('b');person1.sayName(); // 'a'person2.sayName(); // 'b'person1.sayName === person2.sayName // true 整理一下： 构造函数默认有个 prototype 属性指向它的原型 构造函数原型有个 constructor 属性指向构造函数本身 1Person.prototype.constructor === Person 每个 new 出来的实例都有个隐式的 proto 属性，指向它的构造函数的原型 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person Object 本身也是一个构造函数，他也是一个对象 1Object.__proto__ === Function.prototype 此外，Function 的原型属性与 Function 的原型指向同一个对象 123Function.__proto__ === Function.prototypeObject.prototype.__proto__ === nulltypeof Function.prototype === 'function' 3. Object.create()Object.create() 创建的对象会以传入的对象作为原型。 123var obj = &#123;&#125;;var obj2 = Object.create(obj);obj2.__proto__ === obj // true 利用此方法可以模拟对象的“继承” 1234567891011121314151617181920212223function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name; &#125;function Bar(name, label) &#123; Foo.call(this, name); this.label = label;&#125;// temp 原型为 Foo.prototypevat temp = Object.create(Foo.prototype);// new Bar 创建的对象原型为 temp，temp原型为 Foo.prototype,从而 Bar.prototype 和 Foo.prototype 有了继承关系Bar.prototype = temp;Bar.prototype.myLabel = function() &#123; return this.label; &#125;var o1 = new Bar('o1','baro1');o1.myName(); // 'o1'o1.myLabel(); // 'baro1'o1.__proto__.__proto__ === Foo.prototype // true proto 和 prototypeproto 指向 当前对象的原型，而 prototype 为函数才有的属性 默认情况下，new 一个函数创建的对象，其原型都指向构造函数的 prototype 属性指向的对象 特殊情况 js 的内置对象，如 String，Array，Number，Object，Function等，因为为 native 代码实现，所以原型打印出来都是 f(){[native code]} 内置对象本质也是函数，所以可以通过他们创建对象，创建出的对象的原型指向内置函数的 prototype 属性，最顶层的原型对象指向 Object.prototype Object.create(null) 创建的对象不存在原型 constructor、proto 与 prototypeJs 中每创建一个对象，该对象就会获得一个 proto 属性（为一个对象）指向创建该对象的构造函数的原型属性，同时 proto 对象中又有一个 constructor 属性指向该构造函数 只有函数才有 prototype， 每个对象（函数也是对象）都有 proto, Object 本身就是构造函数 进一步探讨js 为单继承; Object.prototype 为原型链的顶端，所有对象从它继承了包括 toString 等方法； Object 为构造函数，它继承了 Function.prototype; Function 为对象，继承了 Object.prototype ; 123Object instanceof Function // trueFunction instanceof Object // true?????!!!!!! 官方给的解释：Function 本身为函数。Function.proto 是标准的内置对象 Function.Prototype,Function.prototype.proto 是标准的内置对象 Object.prototype 总结： 先有 Object.prototype (原型链顶端) Function.prototype 继承自 Object.prototype 产生 最后 Function 、Object 和其他的构造函数继承 Function.prototype 产生 123456function Person(name) &#123; this.name = name; &#125;var person = new Person('a');person.__proto__ === Person.prototypeperson.__proto__.__proto__ === Object.prototypeperson.__proto__ === Function.prototype]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+webpack4+Babel7 脚手架搭建过程（二）]]></title>
    <url>%2F2018%2F12%2F20%2Freact-webpack-babel7-2%2F</url>
    <content type="text"><![CDATA[第二篇主要是 react react-router react-redux React12## 安装 react &amp;&amp; react-domnpm i -s react react-dom 1234567891011import React from 'react';import ReactDOM from 'react-dom';if (module.hot) &#123; module.hot.accept();&#125;ReactDOM.render( &lt;div&gt;Hello React!&lt;/div&gt;, document.getElementById('root'),); 运行可见 Hello React！ React-router1234567891011121314151617181920212223242526272829303132333435363738// install react-router-domnpm i -s react-router-dom`cd src``mkdir router &amp;&amp; touch router/router.js`// router.jsimport React from &apos;react&apos;;import &#123;BrowserRouter as Router, Route, Switch, Link&#125; from &apos;react-router-dom&apos;;import Home from &apos;../containers/Home&apos;;import Page1 from &apos;../containers/Counter&apos;;const getRouter = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/Counter&quot;&gt;counter&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/Counter&quot; component=&#123;Counter&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;);export default getRouter;// 修改src/index.jsimport React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;import getRouter from &apos;./router/router&apos;;ReactDom.render( &#123;getRouter()&#125;, document.getElementById(&apos;root&apos;)); Home 组件： 12345678910// src/containers/Home/index.jsimport React from &apos;react&apos;;const Home = () =&gt; ( &lt;div&gt;this is Home page&lt;/div&gt;);export default Home;// src/containers/Counter/index.js// 略. React-redux12// install redux and react-reduxcnpm i --save redux react-redux src 文件夹下新建 store 文件夹，并创建 index.js 以及 reducer.js 123456789101112131415161718192021222324252627mkdir src/store &amp;&amp; touch src/store/index.js src/store/reducer.js// src/store/index.jsimport &#123; createStore, applyMiddleware, compose,&#125; from &apos;redux&apos;;import reduxThunk from &apos;redux-thunk&apos;;import reducer from &apos;./reducer&apos;;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore( reducer, composeEnhancers( applyMiddleware(reduxThunk), ),);export default store;// src/store/reducer.jsimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as countReducer &#125; from &apos;../containers/Counter/store&apos;;export default combineReducers(&#123; counter: countReducer,&#125;); 修改入口文件 index.js 以及 app.js(分离出了一个app.js,看上去河蟹一些) 123456789101112131415161718192021// src/index.jsimport App from &apos;./app&apos;;...ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;),);// src/app.jsimport React, &#123; Component &#125; from &apos;react&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import store from &apos;./store&apos;;import getRouter from &apos;./router/router&apos;;const App = () =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &#123;getRouter()&#125; &lt;/Provider&gt;);export default App; 通过 Provider 的 store 属性把状态暴露给各个组件方便集中管理使用 接下来实现 Counter 组件 src 目录下的 container 文件夹下 新建 Counter 文件夹，并在文件下下建立如下文件： 12345mkdir src/container/Countertouch src/container/Counter/index.jsmkdir src/container/Counter/storecd src/container/Counter/storetouch constants.js index.js action.js reducer.js 然后编写代码： 定义行为变量 constants ，包含三态：自增、自减以及重置 1234// src/container/Counter/store/constants.jsexport const INCREMENT = 'INCREMENT';export const DECREMENT = 'DECREMENT';export const RESET = 'RESET'; 定义 reducer ，即我们触发 action 会改变 store 里的状态 123456789101112131415161718192021// src/container/Counter/store/reducer.jsimport &#123; INCREMENT, DECREMENT, RESET &#125; from &apos;./constants&apos;;const reducer = (state = &#123; count: 0 &#125;, action) =&gt; &#123; switch (action.type) &#123; case INCREMENT: return &#123; count: state.count + 1, &#125;; case DECREMENT: return &#123; count: state.count - 1, &#125;; case RESET: return &#123; count: 0 &#125;; default: return state; &#125;&#125;;export default reducer; 定义我们的 action 1234567891011121314// src/container/Counter/store/action.jsimport &#123; INCREMENT, DECREMENT, RESET &#125; from './constants';export const incrementAction = () =&gt; (&#123; type: INCREMENT,&#125;);export const decrementAction = () =&gt; (&#123; type: DECREMENT,&#125;);export const resetAction = () =&gt; (&#123; type: RESET,&#125;); 集体导出统一管理：(供根目录的combineReducers消费) 123456// src/container/Counter/store/index.jsimport reducer from './reducer';import * as actionCreator from './action';import * as constants from './constants';export &#123; reducer, actionCreator, constants &#125;; 接下来修改 Counter 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// src/container/Counter/index.jsimport React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; incrementAction, decrementAction, resetAction &#125; from &apos;./store/action&apos;;const Counter = (props) =&gt; &#123; const &#123; count, increment, decrement, reset, &#125; = props; return ( &lt;div&gt; &lt;div&gt; 当前计数： &#123;count&#125; &lt;/div&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; increment()&#125; &gt; 自增 &lt;/button&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; decrement()&#125; &gt; 自减 &lt;/button&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; reset()&#125; &gt; 重置 &lt;/button&gt; &lt;/div&gt; );&#125;;Counter.propTypes = &#123; count: PropTypes.number.isRequired, increment: PropTypes.func.isRequired, decrement: PropTypes.func.isRequired, reset: PropTypes.func.isRequired,&#125;;const mapStateToProps = state =&gt; (&#123; count: state.counter.count,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; increment: () =&gt; &#123; dispatch(incrementAction()); &#125;, decrement: () =&gt; &#123; dispatch(decrementAction()); &#125;, reset: () =&gt; &#123; dispatch(resetAction()); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(Counter); Redux-thunkredux-thunk 使得 action 可以返回一个函数组为返回值 12345678// 创建一个json 作api请求结果mkdir api &amp;&amp; touch api/user.json// user.json&#123; "name": "somnus", "intro": "silly b"&#125; 同理，在 container 文件夹下创建如下目录结构： 接下来是类似的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// UserInfo/store/index.jsimport reducer from &apos;./reducer&apos;;import * as constants from &apos;./constants&apos;;import * as action from &apos;./action&apos;;export &#123; reducer, constants, action,&#125;;// UserInfo/store/constants.jsexport const GET_USER_INFO_REQUEST = &apos;GET_USER_INFO_REQUEST&apos;;export const GET_USER_INFO_SUCCESS = &apos;GET_USER_INFO_SUCCESS&apos;;export const GET_USER_INFO_FAIL = &apos;GET_USER_INFO_FAIL&apos;;// UserInfo/store/action.jsimport &#123; GET_USER_INFO_REQUEST, GET_USER_INFO_SUCCESS, GET_USER_INFO_FAIL,&#125; from &apos;./constants&apos;;const getUserInfoRequest = () =&gt; (&#123; type: GET_USER_INFO_REQUEST &#125;);const getUserInfoSuccess = userInfo =&gt; (&#123; type: GET_USER_INFO_SUCCESS, userInfo,&#125;);const getUserInfoFail = () =&gt; (&#123; type: GET_USER_INFO_FAIL &#125;);const getUserInfo = () =&gt; (dispatch) =&gt; &#123; dispatch(getUserInfoRequest()); return fetch(&apos;/api/user.json&apos;) .then(res =&gt; res.json()) .then(json =&gt; dispatch(getUserInfoSuccess(json))) .catch(() =&gt; dispatch(getUserInfoFail()));&#125;;export default getUserInfo;// UserInfo/store/reducer.jsimport &#123; GET_USER_INFO_REQUEST, GET_USER_INFO_SUCCESS, GET_USER_INFO_FAIL &#125; from &apos;./constants&apos;;const initState = &#123; isLoading: false, userInfo: &#123;&#125;, errorMsg: &apos;&apos;,&#125;;const reducer = (state = initState, action) =&gt; &#123; switch (action.type) &#123; case GET_USER_INFO_REQUEST: return &#123; ...state, isLoading: true, &#125;; case GET_USER_INFO_SUCCESS: return &#123; ...state, isLoading: false, userInfo: action.userInfo, &#125;; case GET_USER_INFO_FAIL: return &#123; isLoading: false, errorMsg: &apos;request error&apos;, &#125;; default: return state; &#125;&#125;;export default reducer;// UserInfo/index.jsimport React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import getUserInfoAction from &apos;./store/action&apos;;const UserInfo = (props) =&gt; &#123; const &#123; userinfo: &#123; userInfo, isLoading, errorMsg &#125;, getUserInfo, &#125; = props; return ( &lt;div&gt; &#123;isLoading ? &apos;请求信息中...&apos; : errorMsg || ( &lt;div&gt; &lt;p&gt;用户信息&lt;/p&gt; &lt;p&gt; 用户名： &#123;userInfo.name&#125; &lt;/p&gt; &lt;p&gt; 介绍： &#123;userInfo.intro&#125; &lt;/p&gt; &lt;/div&gt; )&#125; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; getUserInfo()&#125; &gt; 请求用户信息 &lt;/button&gt; &lt;/div&gt; );&#125;;UserInfo.propTypes = &#123; userinfo: PropTypes.shape(&#123; isLoading: PropTypes.bool.isRequired, userInfo: PropTypes.objectOf(PropTypes.string).isRequired, errorMsg: PropTypes.string.isRequired, &#125;).isRequired, getUserInfo: PropTypes.func.isRequired,&#125;;const mapStateToProps = state =&gt; (&#123; userinfo: state.userinfo,&#125;);export default connect( mapStateToProps, dispatch =&gt; (&#123; getUserInfo: () =&gt; &#123; dispatch(getUserInfoAction()); &#125;, &#125;),)(UserInfo);// 不要忘了 在根目录下 reducer 引入// src/store/reducer.jsimport &#123; reducer as userInfoReducer &#125; from &apos;../containers/UserInfo/store&apos;;export default combineReducers(&#123; counter: countReducer, userinfo: userInfoReducer,&#125;); 最后偷个图： 自己连抄带查，搞定了一个脚手架，记录一下。学习就是不断做一件事1000遍以上的过程，加油。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>webpack babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+webpack4+Babel7 脚手架搭建过程（一）]]></title>
    <url>%2F2018%2F12%2F19%2Freact-webpack-babel7-1%2F</url>
    <content type="text"><![CDATA[第一篇主要是 webpack babel eslint webpack首先新建个空的文件夹并通过 终端进入（后续所有操作基于终端） 1mkdir quick-start &amp;&amp; cd quick-start Webpack 的安装需要借助于 npm ，所以我们您需要创建一个 package.json Package.json 是一个标准的 npm 说明文件，里面保存着当前项目的基本信息，项目依赖以及自定义脚本任务等。 终端中使用 npm init 命令创建 package.json 执行 npm init 命令依次输入项目信息，或者直接 npm init -y 跳过这些信息的输入 123456789101112131415npm init -y## 执行后得到如下信息&#123; "name": "quick-start", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 准备工作完成，开始安装 webpack webpack 4之后分成了 webpack 以及 webpack-cli 两个依赖，所以我们依次安装 1npm i -D webpack webpack-cli 接下来我们需要 创建一些文件和文件夹 当前目录下创建 src dist​ 两个文件夹 并在 src 里面创建两个文件 index.js index.html 1mkdir dist src &amp;&amp; touch src/index.js src/index.html webpack 4 之后打包默认会寻找 src/index.js 作为默认入口，可以直接终端输入 webpack 来查看打包 我们在 index.js 中写入了 console.log(‘index.js’) 打包完成后可以看到 dist 文件夹下多出了 main.js Node 运行一下就可看到输出： 12node dist/main.jsindex.js 细心的你应该会看到终端的黄色警告提示： 123WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ 这是因为 webpack 打包要指定打包环境，开发以及生产环境：webpack --mode=development​ 或者 webpack --mode=production区别在于代码会不会帮你做自动压缩 接下来根目录手动创建 webpack.config.js 1touch webpack.config.js 简单编辑下： 12345678910111213141516171819202122const path = require('path');module.exports = &#123; // 打包 mode: 'development', // 入口文件配置项 entry: &#123; index: './src/index.js' &#125;, // 出口文件配置项 output: &#123; // 打包路径 path: path.resolve(__dirname, './dist'), // 打包文件名 filename: 'bundle.js' &#125;, // 模块：loaders加载 module: &#123;&#125;, // 插件配置 plugins: [], // 配置webpack开发服务 devServer: &#123;&#125;&#125;; webpack 配置文件我们已经定义好，接下来编辑 package.json 中的 scripts 字段，让webpack 打包的时候 使用我们定义好的配置打包 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack --config webpack.config.js"&#125;, 12345678910111213$ npm run build&gt; quick-start@1.0.0 dev /Users/somnus/Desktop/myproject/github/quick-start&gt; webpack --config webpack.config.jsHash: 57f5ff0df67788bc0fcdVersion: webpack 4.27.1Time: 70msBuilt at: 2018-12-19 15:04:05 Asset Size Chunks Chunk Namesbundle.js 3.79 KiB index [emitted] indexEntrypoint index = bundle.js[./src/index.js] 23 bytes &#123;index&#125; [built] 查看 dist 文件夹下已经成功打包的 bundle.js 文件 接下来你可能会考虑，如果我们有多个入口呢？我们在改写一下 webpack.config.js 1234567891011entry: &#123; index: './src/index.js', app: './src/app.js'&#125;,// 出口文件配置项output: &#123; // 打包路径 path: path.resolve(__dirname, './dist'), // 打包文件名 filename: '[name].js'&#125;, 继续执行 npm run dev ，结果如下： 1234567891011Hash: 7b6921f72326bf752b36Version: webpack 4.27.1Time: 73msBuilt at: 2018-12-19 15:09:11 Asset Size Chunks Chunk Names app.js 3.76 KiB app [emitted] appindex.js 3.79 KiB index [emitted] indexEntrypoint index = index.jsEntrypoint app = app.js[./src/app.js] 0 bytes &#123;app&#125; [built][./src/index.js] 23 bytes &#123;index&#125; [built] 可以看到预期的文件输出。 注意：[name] 的含义就是根据入口文件的名称来进行打包 接下来安装 webpack-dev-server ，并简单配置一下 1npm i -D webpack-dev-server 1234567devServer: &#123; port: 3000, // 端口 open: true, // 自动打开浏览器 hot: true, // 开启热更新 overlay: true, // 浏览器页面上显示错误 historyApiFallback: true&#125; 同样再去 package.json 设置脚本运行 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack --config webpack.config.js", "dev": "webpack-dev-server --config webpack.config.js"&#125;, npm run dev 出现如下结果表示运行成功 接下来需要配置一下 html 模板，虽然webpack帮我们打包了js，但是我们不能每次都去html中引用打包生成的js吧，所以借用一个插件来帮我们实现 js 的自动引入 安装插件 html-webpack-plugin 1npm i -D html-webpack-plugin 配置 webpack 配置（多页面） 1234567891011121314151617181920212223const HtmlWebpackPlugin = require('html-webpack-plugin');// 多页面配置entry: &#123; index: './src/index.js', // 入口文件 admin: './src/admin.js'&#125;,plugins: [ new HtmlWebpackPlugin(&#123; // html模板 template: './src/index.html', filename: 'index.html', chunks: ['index'], hash: true, // 打包文件追加 hash 串 &#125;), new HtmlWebpackPlugin(&#123; // html模板 template: './src/admin.html', filename: 'admin.html', chunks: ['admin'], hash: true, // 打包文件追加 hash 串 &#125;)], 重新编译打包，审查元素会看到，已经自动帮我们吧 js 引入到了html中： loader可以针对各类引入的资源做转换加载，解析成浏览器能解析的格式 CSS loader1npm i -D style-loader css-loader 引入less​ 文件的话，也需要安装对应的 loader​，此处以sass为例 12## npm i less less-loader -Dnpm i node-sass sass-loader -D 新建 index.sass 并在 index.js 中引入 12345678touch src/index.sass## index.sassbody background: red## index.jsimport './index.sass' 编辑 webpack modules 配置 1234567rules: [ &#123; test: /\.(sc|sa|c)ss$/, use: ['style-loader', 'css-loader', 'sass-loader'] //右向左解析 &#125;]## test为匹配项 use为使用的loader 重新打包编译发现，此时打包后的 css 是以行内样式的标签引进的，我们更希望用 link 的方式引进，需要用一个插件 extract-text-webpack-plugin 插件，它功效在于将 css 文件 拆分提取 安装 extract-text-webpack-plugin 插件 12// @next 表示可支持 webpack4 的版本npm i -D extract-text-webpack-plugin@next 配置 CSS loader 123456789101112131415const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')// loader&#123; test: /\.(sc|sa|c)ss$/, use: ExtractTextWebpackPlugin.extract(&#123; // css link 方式引入就不需要 style-loader fallback: 'style-loader', use: ['css-loader', 'sass-loader'] //右向左解析 &#125;)&#125;// plugins中定义// 拆分后会把css文件放到dist目录下的css/style.cssnew ExtractTextWebpackPlugin('css/style.css') webpack 4 采用mini-css-extract-plugin 123456789101112131415npm i -D mini-css-extract-plugin // for webpack 4// webpack.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin')// loader&#123; test: /\.(sc|sa|c)ss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'] //右向左解析&#125;// pluginsnew MiniCssExtractPlugin(&#123; filename: 'css/style.css'&#125;) 重新打包编译，查看页面如下： 同理 图片引用 我们需要用到 file-loader 和 url-loader1234567891011121314npm i -D file-loader url-loader&#123; test: /\.(jpe?g|png|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: '8192', // 小于8k自动转成base64，不会存在实体图片 outputPath: 'images' // 打包存放目录 &#125; &#125; ]&#125; 页面 img 标签 引用图片123456npm i -D html-withimg-loader&#123; test: /\.(htm|html)$/, use: 'html-withimg-loader'&#125; 引用字体和svg 可以用 file-loader1234&#123; test: /\.(eot|ttf|woff|svg)$/, use: 'file-loader'&#125; 基本的引用就差不多这些，接下来需要对 CSS 做一些优化 例如：我们想自动根据浏览器来为我们声明的 CSS3 添加兼容前缀，我们需要用到： postcss autoprefixer12345678910111213141516171819202122232425262728// 一如既往的安装npm i -D postcss-loader autoprefixer// 项目根目录创建 postcss.config.jstouch postcss.config.js// 文件中写入module.exports = &#123; plugins: [ require('autoprefixer')(&#123; "browsers": [ "defaults", "not ie &lt; 11", "last 2 versions", "&gt; 1%", "iOS 7", "last 3 iOS versions" ] &#125;) ]&#125;;// 配置 loader// postcss-loader 加在css-loader后&#123; test: /\.(sc|sa|c)ss$/, use: [MiniCssExtractPlugin.loader, 'css-loader','postcss-loader', 'sass-loader'] //右向左解析&#125; CSS 模块化1234567891011// 配置css loader&#123; loader: 'css-loader', options: &#123; module: true, importLoaders: 1, localIdentName: '[name]_[local]_[hash:base64]', sourceMap: true, minimize: true &#125;&#125;, 要启用 CSS 模块化，我们需要设置 css-loader 的 module 选项为 true。 importLoaders 选项表示在 css-loader 之前应用多少个加载器。 例如，sass-loader 必须先于 css-loader 出现。localIdentName 允许配置生成的标识： [name]：css 文件名称 [local]：类/id 的名称 [hash:base64]：随机生成的 hash，它在每个组件的 CSS 中都是唯一的 消除未使用的css123456789101112131415// 安装PurifyCSS-webpacknpm install --save-dev purifycss-webpack purify-css// 在webpack.config.js中引入globconst glob = require('glob');// 在webpack.config.js中引入purifycss-webpackconst PurifyCSSPlugin = require("purifycss-webpack");//配置webpack.config.js中的pluginsplugins:[ new PurifyCSSPlugin(&#123; paths: glob.sync(path.join(__dirname, 'src/*.html')), &#125;)] 测试一下，在引用的css中定义一个未使用的样式声明，编译打包后查看编译后的css 文件，是不是已经被清除了 babel7 转义ES6和react笔者使用的 babel7 ，接下来安装 1npm i -D babel-loader@8 @babel/core @babel/preset-env @babel/preset-react babel-loader：使用 Babel 转换 JavaScript依赖关系的 Webpack 加载器 @babel/core：即 babel-core，将 ES6 代码转换为 ES5 @babel/preset-env：即 babel-preset-env，根据您要支持的浏览器，决定使用哪些 transformations / plugins 和 polyfills，例如为旧浏览器提供现代浏览器的新特性 @babel/preset-react：即 babel-preset-react，针对所有 React 插件的 Babel 预设，例如将 JSX 转换为函数 12345678910111213141516// 根目录创建babel配置文件touch .babelrc// 简单配置&#123; "presets": ["@babel/preset-env", "@babel/preset-react"]&#125;// 配置 loader&#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader' &#125;&#125; 清理 dist 文件夹每次 build 之后都会重新生成文件至 dist 文件夹，我们需要每次 编译后自动清除 dist 文件夹内容，借助插件 clean-webpack-plugin 12345678910npm i -D clean-webpack-pluginlet CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; plugins: [ // 打包前先清空 new CleanWebpackPlugin('dist') ]&#125; 提取公共代码1234567891011121314151617181920212223242526//在webpack4之前，提取公共代码都是通过一个叫CommonsChunkPlugin的插件来办到的。到了4以后，内置了一个一模一样的功能 optimizationoptimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125;, utils: &#123; // 抽离自己写的公共代码，utils里面是一个公共类库 chunks: 'initial', name: 'utils', // 任意命名 minSize: 0 // 只要超出0字节就生成一个新包 &#125; &#125; &#125;&#125;,// 还要在plugins里面引入需要单独打包出来的chunknew HtmlWebpackPlugin(&#123; template: './src/index.html', chunks: ['vendor', 'index', 'utils'] // 引入需要的chunk&#125;), 配置 dev-server1234567devServer: &#123; port: 3000, // 端口 open: true, // 自动打开浏览器 hot: true, // 开启热更新 overlay: true, // 浏览器页面上显示错误 historyApiFallback: true&#125;, devtool优化12// 在开发环境下配置devtool: 'eval-source-map' 热更新12345678910111213141516171819// webpack.config.jslet webpack = require('webpack');module.exports = &#123; plugins: [ // 热更新，热更新不是刷新 new webpack.HotModuleReplacementPlugin() ], devServer: &#123; hot: true, // 加上这一行 &#125;&#125;// 在入口文件index.js// 还需要在主要的js文件里写入下面这段代码if (module.hot) &#123; // 实现热更新 module.hot.accept();&#125; webpack merge12345678910111213141516171819const path = require('path')const webpack = require('webpack')const merge = require('webpack-merge')const common = require('./webpack.common')module.exports = merge(common, &#123; plugins: [ new webpack.HotModuleReplacementPlugin(), ], mode: 'development', devServer: &#123; port: 3000, // 端口 open: true, // 自动打开浏览器 hot: true, // 开启热更新 overlay: true, // 浏览器页面上显示错误 historyApiFallback: true &#125;, devtool: 'eval-source-map',&#125;) eslint统一的代码风格对于团队合作不可或缺。 123456789101112131415161718192021// 安装 eslintnpm --save-dev install eslint// 因为我们使用了webpack，所以必须要告诉webpack我们在构建时使用eslint，安装eslint-loadernpm --save-dev install eslint-loader// 配置loader&#123; test: /\.js$/, exclude: /node_modules/, use: ['babel-loader', 'eslint-loader']&#125;,// 同理根目录创建配置文件touch .eslintrc// 编辑 .eslintrc&#123; "rules": &#123; &#125;&#125; 稍后我们可以在该文件中指定规则，但首先我们要在Webpack配置文件中引入该文件。 plugins中定义: 12345678new webpack.LoaderOptionsPlugin(&#123; // test: /\.xxx$/, // may apply this only for some modules options: &#123; eslint: &#123; configFile: './.eslintrc' &#125; &#125;&#125;) 添加完成运行会发现 ES6 语法会报错 我们可以通过 babel-eslint 来检测ES6代码 123456789// 安装 babel-eslintnpm install --save-dev babel-eslint// 修改.eslintrc&#123; parser: "babel-eslint", "rules": &#123; &#125;&#125; 添加规则 12345678&#123; "parser": "babel-eslint", "rules": &#123; "max-len": [1, 120, 2, &#123;"ignoreComments": true&#125;] &#125;&#125;// 安装 react lintnpm install -D eslint-plugin-react 安装之后，我们可以使用react插件来指定我们关于react的第一条代码规则。比如我们要求组件指定PropTypes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// .eslintrc&#123; parser: "babel-eslint", "plugins": [ "react" ], "rules": &#123; "max-len": [1, 120, 2, &#123;ignoreComments: true&#125;], "prop-types": [2] &#125;&#125;// 扩展ESLint规则 Airbnb Style Guidenpm install -D eslint-config-airbnb eslint-plugin-import eslint-plugin-jsx-a11y// 修改.eslintrc配置&#123; "parser": "babel-eslint", "extends": "airbnb", "rules": &#123; "max-len": [1, 120, 2, &#123;"ignoreComments": true&#125;], "prop-types": [2] &#125;&#125;// 调整&#123; "parser": "babel-eslint", "extends": "airbnb", "plugins": [ "react", "jsx-a11y", "import" ], "rules": &#123; "max-len": [1, 120, 2, &#123;"ignoreComments": true&#125;], "prop-types": [0], "no-console": 1, "react/jsx-filename-extension": [1, &#123; "extensions": [".js", ".jsx"] &#125;] &#125;, "env": &#123; "browser": true, "node": true &#125;&#125;// bugResolve error: unable to load resolver "node"// 解决方案npm install -D eslint-import-resolver-node pre-commitgit pre-commit 提交前检测 如果检测失败则禁止提交。可以在很大一定程度上保证代码质量 123456789101112// pre-commit hook"scripts": &#123; "eslint": "eslint --ext .js src"&#125;// 安装npm i -D pre-commit// package.json:"pre-commit": [ "eslint"]]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>webpack babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行上下文和执行栈]]></title>
    <url>%2F2018%2F12%2F08%2FExecution-Context%2F</url>
    <content type="text"><![CDATA[又来过基础 执行上下文什么是执行上下文Execution Context（执行上下文）就是定义变量或函数有权访问的其他数据，并决定了他们的行为。根据所在环境的不同一共有三种类型： 全局执行上下文 默认、最基础的执行上下文，且一个程序只能存在一个全局上下文 函数执行上下文 每次 调用 都会创建一个新的执行上下文 Eval 函数执行上下文 运行在 eval 函数内的代码有着自己的执行上下文 执行栈先进后出的结构，用于存储代码执行期间创建的所有执行上下文JavaScript 引擎开始读取脚本时，先默认创建一个全局执行上下文并将其推入栈底，每发生一个函数调用，引擎就会为该函数创建一个新的执行上下文并压入栈。引擎会运行处于执行栈栈顶的函数，运行完后，其对应的上下文从栈中弹出，交还控制权给当前执行上下文的下一个执行上下文12345678910function foo(y) &#123; var sum = foo1(y) + 1 console.log(sum)&#125;function foo1(x) &#123; return x+1&#125;foo(5) 执行栈简图如下：注：每次函数调用都会创建新的 执行上下文，哪怕是递归调用 执行上下文的创建执行上下文分两个阶段创建： 1）创建阶段 2）执行阶段 创建阶段（函数被调用，代码未执行）1. 初始化作用域链 2. 创建变量对象 3. 创建参数对象，检查参数上下文，初始化其名称和值并创建一个引用拷贝 4. 扫描函数声明，对于未发现的函数在变量对象中创建一个同名属性，如果已经存在的发生**覆盖** 5. 扫描变量声明，未被发现的在变量对象中创建一个同名属性并初始化为 undefined，如果已存在，**跳过** 6. 确定上下文中的 this 注：如果 let 以及 const 声明创建阶段会跳过初始化 执行阶段赋值、寻找函数引用以及解释/执行代码 所以执行上下文类似结构为：12345executionContextObj = &#123; 'scopeChain': &#123; /* 变量对象 + 所有父级执行上下文的变量对象*/ &#125;， 'variableObject': &#123; /* 函数参数、 参数，内部变量以及函数声明 */ &#125;， 'this': &#123;&#125;&#125; 变量对象（VO）和活动对象（AO）当当前上下文执行时，变量对象变成活动对象，所以区别只是同一对象在执行上下文的不同阶段而已 12345678910111213141516171819202122232425262728293031323334353637383940funtion foo(i) &#123; var a = 'hello' var b = function foo2() &#123;&#125; function c() &#123;&#125;&#125;foo(10)函数调用的创建阶段：fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125;执行阶段：fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() &#125;, this: &#123; ... &#125;&#125; 提升变量以及函数声明的提升，原理就在于解析器创建变量对象的过程，不啰嗦。 结语知其然，知其所以然，想必是极好的]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 变量与内存]]></title>
    <url>%2F2018%2F12%2F01%2Fjs-types%2F</url>
    <content type="text"><![CDATA[JavaScript 变量与内存 知其然，知其所以然 变量根据 ECMA-262 定义，JavaScript 中的变量区别于其他编程语言。JavaScript 中的变量只是用于保存特定值的名称，而变量的值数据类型可在脚本的生命周期改变。也就是说“变量无类型，有类型的是变量的值” 数据类型JavaScript 中变量值可能包含两种数据类型：基本类型 和 引用类型。 基本类型ES5 中有五种基本数据类型：Undefined Null Boolean Number String，ES6 新增 Symbol基本类型数据都是保存在栈中的简单数据，按值来访问的，可直接操作保存在变量中的实际的值基本类型的值是不允许更改的，当你修改了变量的值，所做的只是创建了新值并复制到了原先变量值的位置 引用类型引用类型的值为保存在内存中的对象，区别于其他语言，JavaScript 中不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。而实际上对对象的操作是对对象引用的操作。 动态属性两种类型定义方式类似：创建变量并为变量赋值，但不同类型值可进行的操作却有不同：我们可以为引用类型数据添加属性和方法，也可改变和删除属性和方法，而对于基本类型是不可以的1234567var a = &#123;&#125;a.b = 'test'a.b //testvar a = 1;a.test = 'test data'a.test //undefined 变量复制除了变量存储方式不同，变量的复制也存在着不同向一个变量复制一个基本类型的值时，会创建新值然后赋值到新变量分配的位置12345678910111213141516171819202122var a = 1;var b = a; 复制前的变量对象 ________________________________ | | | | | | |__________|_____________________| | | | | a | 1 | |__________|_____________________| ___________________________________ 复制后的变量对象 ________________________________ | | | | a | 1 | |__________|_____________________| | | | | b | 1 | |__________|_____________________| 当从一个变量向另一个变量复制引用类型的值时，同样的也会将存储在变量对象中的值复制一份并放置与新变量分配的空间，不同的是值的副本是一个指针，指针指向存储在堆内存的对象。复制后，两个变量引用同一个对象，即修改一个变量的值也会影响另一个。123456789101112131415161718192021222324var obj1 = &#123;&#125;;var obj2 = obj1;obj1.name = 'test';obj2.name //test 复制前的变量对象 堆内存 ________________________________ ________________________________________ | | | | | | | | | | |__________|_____________________| | ___________ | | | | | | | | | obj1 | object 引用 ---------------------------| object | | |__________|_____________________| | | |__________| | | | | ___________________________________ | |_______________________________________| | 复制后的变量对象 | ________________________________ | | | | | | obj1 | object 引用 ----------| |__________|_____________________| | | | | | | obj2 | object 引用 ----------| |__________|_____________________| 内存管理JavaScript 具有自动垃圾收集机制，也就是说执行环境会负责追踪代码执行过程中使用的内存，而非 C C++ 之类的语言需要开发者去手动释放内存。故编写 JavaScript 脚本时，开发人员无需关注内存的使用，所需要的内存分配以及回收都实现了自动管理。垃圾收集器会按照固定的时间间隔（或代码执行的预定时间间隔），找出不再继续使用的变量然后释放其占用的内存。垃圾收集器运行时，会对无用的变量进行标记，备将来收回所占内存。而标记无用变量的策略因实现而异，具体到浏览器的实现主要有如下两种： 标记清除最常用的垃圾收集方式。1234567来自MDN https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management把“对象是否不再需要”简化定义为“对象是否可以获得”。假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。 引用计数跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋值给该变量，则这个值的引用次数为 1。 如果同一个值被赋值给另一个变量，引用次数加一。相反如果包含值引用的变量取得另一个值，那么引用次数减 1.当这个值的应用次数变成 0，则对其占用内存空间进行回收。 不足循环引用，两个值的引用次数都是 2，不会被回收123456function foo()&#123; var a = &#123;&#125; var b = &#123;&#125; a.bAttr = b; b.aAttr = a;&#125; 写在结尾基础！基础！基础！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone X 适配]]></title>
    <url>%2F2018%2F02%2F13%2Fiphone-x%2F</url>
    <content type="text"><![CDATA[这篇文章迟到了很久，暂且记录一下自己遇到的坑 html5网页因为目前就职公司采用的H5响应式驱动的主体项目，app 都是基于的 webview 开发，当 iPhone X 上市后，适配促成了新的兼容任务。 新属性为了更好的适配 iPhone X，iOS 11 新增了几个特性用于处理那诡异的刘海屏。苹果公司还对 iPhone X 的屏幕内容作了安全距离限定，美其名曰为了更好的用户体验，其实就是为了填自己的坑。。 viewport-fitiOS11 新增特性，为了适应 iPhone X 对现有的 viewport meta 标签的一个扩展，定义网页在可视窗口的布局方式。safari 浏览器中开发模式可勾选支持调试。属性： contain：可视窗口包含网页内容，即内容会在安全区域显示 cover：网页内容覆盖可视窗口 auto： 默认值，同contain表现是一致的 详情见文档 constantiOS11 新增特性，webkit 的 css 函数，用于设定安全区域与边界的距离，有四个预定义变量。 safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 我们需要关注的就是 safe-area-inset-bottom，对应也就是底部小黑条的处理同时需要注意的就是，viewport-fit 为 contain 时，constant 函数是不起作用的，需要配合 cover 使用，不支持 constant 的浏览器会被忽略此属性 其实有些人会有些疑惑，很明显设计稿下面空出的距离就是 68 像素（2倍设计稿），但是网页适配你要兼容旋转屏幕，所以乖乖用人家的不要闹。 env（iOS 11.2后支持，兼容处理）这是当初比较坑的一点，同事的突然一波更新，整个人陷入绝望，窝草！说好的适配呢，都不生效了！！后来又查了查，哦，11.2 以后支持这个属性了，constant 废除了。。可定义的值并无任何变化，只是函数名变了，略。 适配方案官方给的建议就是，列表或者内容建议通底显示，黑条压了就压了，反正可以滑动内容，至于底部有悬浮固定操作的交互时候，建议做兼容处理。 设置网页窗口的布局方式 viewport meta 标签添加 viewport-fit=cover属性 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt; 页面内容主体限定安全区域 为了避免列表尾项或者主体内容受到小黑条遮挡，我们需要对 body 做一些处理 123456body &#123; /* iOS 11.0 */ padding-bottom: constant(safe-area-inset-bottom); /* 11.2+ */ padding-bottom: env(safe-area-inset-bottom);&#125; 底部悬浮交互按钮 一般大多数需要做兼容处理的就是这种，web应用的底部导航菜单。 我们需要对吸底按钮做内边距处理，增加扩展高度，注意吸底元素最好设置个背景色，不然会镂空网站主体背景色 123456&#123; /* iOS 11.0 */ padding-bottom: constant(safe-area-inset-bottom); /* 11.2+ */ padding-bottom: env(safe-area-inset-bottom);&#125; 或者通过 css 的计算函数 calc 来增加高度 1234&#123; height: calc(50px(预设值) + constant(safe-area-inset-bottom)); height: calc(50px(预设值) + env(safe-area-inset-bottom));&#125; 除此之外，有些悬浮按钮也需要处理，例如返回顶部之类，同样的通过计算函数增加定位元素的 bottom 值 1234&#123; bottom: calc(50px(预设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(预设值) + env(safe-area-inset-bottom));&#125; 需要注意的是：calc 属性计算中间的空格不可忽略，代码压缩会有点坑此处 属性兼容处理 support 我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 实现： 123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; fixedDiv &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 小程序小程序的处理相对就比较无脑，通过或许手机信息接口拿到是否为 iPhone X,然后做相应的样式处理123456789// 获取手机信息wx.getSystemInfo(&#123; success: function (res) &#123; let model = res.model.substring(0, res.model.indexOf(&quot;X&quot;)) + &quot;X&quot;; if (model == &apos;iPhone X&apos;) &#123; that.globalData.isIpx = true &#125; &#125;&#125;) 注意：小程序 webview 中的适配采用h5的网页适配属性不生效，需要通过参数传递然后动态添加 class 做样式处理 app如果业务逻辑是由 app 驱动，直接甩好 webview 距离就好，如果是 web 驱动，建议移交 web 来做底部兼容 后话大过年的在家懒了好几天终于开始用笔记本干正事系列。。(碎碎念，讲道理浏览量这么少的东西，我就没必要定性自己写的是技术博客了)]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 下面那些让人抓狂的东西]]></title>
    <url>%2F2017%2F10%2F08%2Fwindows-about%2F</url>
    <content type="text"><![CDATA[作为一个混迹windows的程序员，没事重装一下电脑简直和吃饭一样简单，但是每次装完都会被有些东东恶心到。。 系统重装开机的无效索引装完系统，如果是u盘安装之类的话，大都会多出一个无效索引，也就是旧系统的索引，不能忍！ Win + R 键入 msconfig，打开系统配置 点击 “引导” 菜单进行管理，删除无效项即可 window.old文件夹删除“Windows.old” 文件夹包含升级win10前系统的 “Windows”、“Program Files”、“Users”这三个目录中的文件，将之前的系统文件和安装的程序文件都做了备份。这是微软出于人性化的考虑，让没有来得及备份重要文件的用户可以再次选择备份。对不起，我不打算考虑！ 系统盘右键 - 属性 - 磁盘清理 扫描完成 - 清理系统文件 列表中勾选”以前的Windows安装”，确定，待完成退出 dll库errorMSVCR10.dll曾经困扰我多次的东东，每次都要百度一下，捉急！安装对应版本的VC库 vcredist_x64.exe 和vcredist_x86.exe下载地址：vcredist.exe 软件errorchrome熟悉的提示：“Google Chrome 未响应。是否立即重新启动”，选项给你的选择并不能解救你。 Win + R 输入 cmd 打开命令行 输入 taskkill /f /im chrome.exe ,回车执行 重新打开Google Chrome Wampserver经常本地 demo 手机测试都会暂时用它架一个静态服务器，之前 php 学习用的工具，但 php 早忘光了。安装完成不做一点配置的话就会出现手机访问 403，做个备份省的再查。 关闭防火墙 修改 apache 目录下的 httpd.conf文件 12//path: apache\apache2.4.17\conf\httpd.conf 291行左右修改 Require local =&gt; Require all granted 修改 httpd-vhosts.conf 文件 12//path: 目录下搜索 httpd-vhosts.conf 找到 &lt;VirtualHost *:80&gt;节点上的所有虚拟站点修改 Require local =&gt; Require all granted 重启服务 注：此方法仅支持2.4以后的版本 百度云说不上是错误，但是着实恶心，安装完百度云自动帮你在我的电脑添加一个“百度云管家”的盘符快捷方式，真心逼死强迫症。打开百度云，设置 - 基本 - 在我的电脑中显示百度云管家，默认是勾选状态，去除勾选 - 应用 - 确定。如果成功，下面的可以无视。 Win + R 键入 regedit 进入注册表编辑 依次展开 HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ Explorer \ MyComputer \ NameSpace，删除 NameSpace 下面的 {679F137C-3162-45da-BE3C-2F9C3D093F64} 项 若无，跳至第4步。 在 NameSpace 项上点右键 - 权限，依次操作 - 高级 - Administrators - 编辑 - 创建子项 - 拒绝 依次展开 HKEY_CURRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Explorer \ MyComputer \ NameSpace ，删除 {679F137C-3162-45da-BE3C-2F9C3D093F64} 项 退出刷新。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Repaint/Reflow到css选择器]]></title>
    <url>%2F2017%2F10%2F05%2Fcss-seletor%2F</url>
    <content type="text"><![CDATA[什么是Repaint/Reflow?先扒一张图，来解释下浏览器的工作流程 上图可归纳为四步： 解析构建 DOM 树 渲染引擎开始解析 html 文档，转换树中的标签或者生成的标签到 DOM 节点，这时的它称为内容树 构建渲染树 解析所有 CSS,并据此计算节点样式，创建渲染树 布局渲染树 从根节点递归调用，计算元素的大小位置，并把每个节点放在该出现的精准坐标位置 绘制渲染树 遍历渲染树，每个节点使用 UI 后端层绘制 从以上不难看出，Repaint 和 Reflow 发生在了第三四步，故给出定义：浏览器在解析页面时，根据 css 以及 js来计算并把相应的元素置于该出现的位置，这个过程就是 Reflow;当元素的位置大小颜色确定后，浏览器会按照各自的属性进行绘制，这个过程就是 Repaint。故我们需要避免引发此类操作，以此来提高渲染速度。 引起Repaint/Reflow的一些操作Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 如何优化Reflow是不可避免的，只能将Reflow对性能的影响减到最小,给出下面几条建议： 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className： 1234567// 不推荐的写法var left = 10,top = 10;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;;// 推荐写法el.className += &quot; theclassname&quot;; 把 DOM 离线后修改。如： a&gt; 使用 documentFragment 对象在内存里操作 DOM。 b&gt; 先把 DOM 给 display:none (有一次 repaint)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。 c&gt; clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是会大大减小 reflow 。 尽量不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 css选择器 上面提到了Repaint和Reflow，以及如何优化的问题。我们知道浏览器工作流程第三步就是解析css然后计算元素位置并放置，那么如何从这点上来提高效率呢？这就要提到css的渲染效率了，下面我们来探讨下。 浏览器如何识别你的选择器浏览器读取你的选择器，遵循的原则是由右向左读取，换句话讲，读取选择器会由右向左进行。举个栗子：1div.header &gt; ul li p 上述选择器，浏览器会尝试在你的 html 标签中寻找 p 元素,接着匹配 li 和 ul，最后再去匹配 div.header,所谓的由右到左就是这样。 选择器的最后一部分，也就是最右边的部分被称为 关键选择器，而它决定着你的选择器效率的高低。而关键选择器的作用就是提高选择器的效率，每少检查一个给定的规则，就会更有效的将样式匹配给对应的html元素。所以我们的方向就是让关键选择器更加有效性能化更高，那么如何实现呢？很简单，关键选择器越具体，性能化就越高。 选择器效率如果你是个合格的前端开发者，对 css 选择器有一定了解的话，应该对那些选择器以及它的优先级不会太陌生。来让我们看下 Steve Souders 大神给的优先级排序： id选择器 (#id) 类选择器 (.class) 标签选择器 (h1,div,p..) 相邻选择器 (h1+p) 子选择器 (div &lt; span) 后代选择器 (div span) 通配符选择器 (*) 属性选择器 (a[rel=’’]) 伪类选择器 (a:hover,li:nth-child(1)) 上述选择器优先级按照降序排列，当然还有上面你没提到的行内样式和 !important，建议还是少用为妙，毕竟对于维护来讲太恶心。 书写高效的css选择器来自Mozilla的几点建议（搬运工）David在《Use efficient CSS selectors》中介绍了几种书写高效率的CSS选择器的方法: 避免普遍规则 不要在 ID 选择器前加标签名或类名 不要在类名选择器前加标签名 尽可能使用具体的类别 避免使用后代选择器 标签分类规则中不应该包含一个子选择器 子选择器的问题 借助相关继承关系 使用范围内的样式表 一些降低渲染资源消耗的实战经验 十六进制颜色值对位数与大小写 默认标准是大写以及 6 位数标注，建议书写规范，虽然未有确实数据表明不采用写法会对渲染速率有影响。 display 与 visibility 差异 两者均用于设置或检索是否显示对象。前者隐藏对象且不保留物理空间，而后者会保存物理空间。浏览器渲染被占据的物理空间时，会有所消耗。建议采用 display:none; border:none; 与 border:0;区别 区别同上, border:0; 把 border 设为 “0” 像素虽然在页面上看不见，但按 border 默认值理解，浏览器依然对 border-width/border-color 进行了渲染，即已经占用了内存值。 border:none; 把 border 设为 “none” 即没有，浏览器解析 “none” 时将不作出渲染动作，即不会消耗内存值。 建议使用border:none; 不宜过小的图片平铺 一张宽高 1px 的背景图片，虽然文件体积非常之小，但渲染宽高500px的板块需要重复平铺 2500 次。提高背景图片渲染效率跟图片尺寸及体积有关，最大的图片文件体积保持约 70KB。建议采用衡量适中体积及尺寸的背景图片 IE的滤镜 IE的滤镜除了比较消耗资源外也有兼容性问题。当中有令 PNG 透明的滤镜，可采用 GIF 或 JPG 似透非透的办法来避免使用此滤镜。建议只在 IE6 应用 GIF 透明，因为 IE7 以上已经支持了 PNG 透明。 通配符*{margin:0;padding:0;} 号通配符把所有标签都初始化一遍，浏览器的渲染消耗一定的资源。有部分在标签在不同浏览器上几乎无差异，或是某些已经不推荐使用的标签(因为你不会去用它)，它们不需通配符要重新初始化一遍这样做能节省一点资源。 推荐方案(代替 reset )：normalize.css(如果没听说过自行百度) 不要添加额外的标签来描述 class 或 id 如果你有一个选择器是以 id 作为关键选择符，请不要添加多余标签名上去。因为 ID 是唯一的，你不要为了一个不存在的理由而降低了匹配的效率。 不赞成 - button#backButton { } 不赞成 - .menu-left #newMenuIcon { } 建议用 - #backButton { } 建议用 - #newMenuIcon { } 尽量选择最特殊的类来存放选择器 降低系统效率的一个最大原因是我们在标签类中用了过多的选择符。通过添加 class 到元素，我们可以将类别进行再细分为 class 类，这样就不用为了一个标签浪费时间去匹配过多的选择符了。 不赞成 - treeitem[mailfolder=”true”] &gt; treerow &gt; treecell { } 建议用 - .treecell-mailfolder { } 避免子孙选择符 子孙选择符是 CSS 中最耗资源的选择符。他真的是非常的耗资源，尤其是在选择器使用标签类或通用类的时候。很多情况中，我们真正想要的是子选择符。除非有明确说明，在 UI CSS 中是严禁使用子孙选择符的。 不赞成 - treehead treerow treecell { } 好一点，但还是不行(参照下一条) - treehead &gt; treerow &gt; treecell { } 标签类中不要包含子选择符不要在标签类中使用子选择符。否则，每次元素的出现，都会额外地增加匹配时间。（特别是当选择器似乎多半会被匹配的情况下） 不赞成 - treehead &gt; treerow &gt; treecell { } 建议用 - .treecell-header { } 留意所有子选择符的使用小心地使用子选择符。如果你能想出一个的不使用他的方法，那么就不要使用。特别是在 RDF 树和菜单会频繁地使用子选择符，像这样。 不赞成 - treeitem[IsImapServer=”true”] &gt; treerow &gt; .tree-folderpane-icon { } 请记住 RDF 的属性是可以在模板中被复制的！利用这一点，我们可以复制那些想基于该属性改变的子 XUL 元素上的 RDF 属性。 建议用 - .tree-folderpane-icon[IsImapServer=”true”] { }. 暂时就这么多了，国庆在家没网，更个东西也是费死个老劲。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC(Block Formatting Content)]]></title>
    <url>%2F2017%2F09%2F19%2Fbfc%2F</url>
    <content type="text"><![CDATA[What is BFC? BFC 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 当涉及到可视化布局的时候，BFC 为我们提供了一个环境，这个环境规定着其布局的规则，而不同环境之间的布局不会相互影响。想要更好的理解这个概念，需要先理解 Box 和 Formatting Context 的概念。网页的布局核心就是盒子的组成排列，这些盒子就是 Box。盒子的类型和 display 属性决定着这个 Box 的类型。不同类型的 Box，会参与不同的 Formatting Context（决定如何渲染文档的格式结构），然后其内元素就会以不同方式渲染。例如： block-level box ：display 属性为 block, list-item, table 的元素，会生成 block-level box， 并参与 block formatting context; inline-level box：display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box， 并参与 inline formatting context 而 Formatting Context 是一块渲染区域，它决定着其子元素如何定位，以及与其他元素的位置关系。通过上面一些概念，建议把 BFC 简单理解为一种属性，在具有此属性的容器中，元素按照 BFC 的规则实现布局。比如浮动元素会形成 BFC，这就是为什么我们看到浮动元素布局跟普通文档流的布局有所差别的原因。 规则是什么呢简单以下几条规则，理解起来不太难。 内部的 box 元素会在垂直方向依次放置，也就是文档流的从上而下 垂直方向距离由 margin（外边距）决定 其内每个元素的 margin box 的左边和包含块 border box 的左边相接触（由右向左的格式化则相反），浮动也如此 BFC 的区域不会与其内浮动元素发成重叠 BFC 就是页面一个隔离的独立容器，内联元素不会对外面元素产生影响，反之亦成立 计算 BFC 高度的时候，浮动元素也参与计算 哪些元素会生成 BFC 根元素 浮动元素，float 属性不为 none 绝对定位元素，position 属性为 absolute 或 fixed（absolute的子类） display 属性为 inline-block，table-cell，table-caption，flex，inline-flex overflow 属性不为 visible 以外值的 css3 中，BFC 叫做 Floe Root，并增加了一些触发条件 BFC 在布局中的作用 解决两元素 margin 重叠问题。 要想两个相邻元素不发生垂直方向的 margin 重叠，需要将他们定义在不同的 BFC 中。解决方法即在其中一个元素外包裹一层元素 ，再对包裹元素进行 BFC 触发（声明以上触发 css 属性）。 解决由于浮动造成的重叠问题。 一般情况下，浮动元素会脱离文档流，即不占用位置。它的性地元素会与它在左上角重叠，但如果两个相邻元素都设置了浮动，那么意味着它们都会以 BFC 的规则渲染，据以上第四条规则，BFC 区域不会相互重叠，所以为什么浮动元素独占空间便能理解了 解决容器由于拥有浮动元素造成的高度塌陷 普通容器中，如果里面有浮动元素，且不设置高度的情况下，容器的高度是无法被撑起的。这时可通过设置 overflow 属性为 hidden 将之声明为 BFC，那么就可以包含浮动元素了]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语初下复习（25-26）]]></title>
    <url>%2F2017%2F08%2F28%2Fnihongo25-26%2F</url>
    <content type="text"><![CDATA[25.これは明日会議で使う資料です 动词（简体形）+ 名词 小句（动词简体形）+ 名词表示某种习惯或将要发生的动作用基本型，如果是已经玩成的动作用 “た形”1これは 明日会議で使う 資料です。 小句（动词简体形）+ 名は 名/形 です动词小句修饰名词形成的名词短语做主语1私が 明日乗る 飛行機は中国航空です。 小句（动词简体形）+ 名を/に/から 动ます动词小句修饰名词形成的名词短语做主语以外的其他部分1中国で買ったCD を 友達に貸しました。 小句（一类形/二类形/名）+ 名一类形容词修饰名词用 基本型，二类形容词修饰名词 + “な“ 修饰，名词修饰名词用 “の“ 修饰123入り口が 広い あの建物は私の会社です。 操作が 簡単な パソコンが欲しいです。 数学が 専門の先生 が休みました。 扩展单词 假名 释义 假名 释义 假名 释义 假名 释义 うえ 上 上面 した 下 下面 なか 中 里边，内部 そと 外 外面 まえ 前 前面 うしろ 後ろ 后面 ひだり 左 左面 みぎ 右 右面 よこ 横 侧面 そば 側 旁边 むかい 向かい 对面 まわり 周り 周围 あいだ 間 中间 すみ 隅 角落 ました 真下 正下方 きた 北 北面 みなみ 南 南面 ひがし 東 东面 にし 西 西面 26.自転車に二人で乗るのは危ないです 小句（动词简体形）+ のは + 形 です动词小句加 “の“ 使其名词化，表示”做某动作“的意思。名词化做主语，谓语为表示性质状态的一类或二类形容词时，主语用助词 “は“12自転車に二人で乗るのは危ないです。パソコンで表を作るのはたのしいです。 如果名词形式为 表示好恶、擅长不擅长之类的对象 时，用助词 “が“ 修饰名词12李さんは絵を書くにが好きですね。はい、色鉛筆でスケッチするのが大好きです。 此外，如果 好恶、擅长不擅长之类的对象当做话题 来讨论，助词用 “は“12絵を書くのは好きですか。いいえ、絵を書くのは嫌いです。 小句（动词简体形）+ の + を + 动词动词小句加 “の“ 的名词化形式可以做宾语。12手紙を出すのを忘れました。森さんが発言するのを聞きまし。 这种名词化形式做宾语时 “の“ 和 “こと“ 可以互换例外： 句尾动词为 しらせます（告诉） 伝えます（转告） 話します（说）等表示 语言行为 的动词时，要用 “こと“ 而不能用 “の“ 1李さんは森さんが休むことを伝えました。 句尾动词为 見ます（看） 聞きます（听） 等表示 感知动作 的动词或 手伝います（帮忙） やめます（停止） 防ぎます（防御） 等表示 直接动作对象 的动词，则使用 “の“ 而不能用 “こと“ 12李さんは森さんが車から降りるのを見ました。李さんは森さんが荷物を運ぶのを手伝いました。 小句（简体形） でしょう [推测]表示说话人对自己和听话人都不能断定的事进行推测，常与 “たぶん“ 呼应使用。动词小句和一类形容词小句用简体形后续 “でしょう“,二类形容词小句和名词小句则把简体形的 “だ“ 换成 “でしょう““でしょう“ 的简体形是 “~だろう“12345明日の朝は大雨になるでしょう。森さんは知らないでしょう。この本の値段は分かりませんが、たぶん高いでしょう。今年はたぶん豊作だろう。これはたぶん誰かの忘れ物だろう。 小句（简体形）かもしれません表示有可能发生某事，其可能性在百分之五十左右。动词小句和一类形容词小句用简体形后续 “かもしれません“,二类形容词小句和名词小句则把简体形的 “だ“ 换成 “かもしれません“12森さんは今日会社を休むかもしれません。クレジットカードを落としたかもしれません。 与 “でしょう“ 相比，”かもしれません“表示的概率较低。 もしかしたら口语场合，用于可能性较低的场合，一般与 “～かもしれません“ “～ではありません“ 等呼应使用12345馬さんはまだ来ませんね。もしかしたら、今日は来ないかもしれませんよ。もしかしたら、太田さんではありませんか。ええ、そうですが。。 それで表示前面句子的时态为后面句子时态的原因、理由12日本に握手の習慣がないんですね。ええ、そうなんです。それで、つい握手するのを忘れます。 “だから” 也表示原因、理由。但是与 “それで” 相比，语气较强，且后面可以使表示其实活着推测的句子，而 “それで“不行1すぐに会議が始まします。だから、急いでください。 つい表示 并非有意 所为确形成了某种后果，并含有对意想不到的结果感到不快、后悔的语感。1バーゲン会場では、つい何でも買いたくなりです。 公司常用寒暄用语 句子 释义 申し訳ありません 对不起，抱歉 どうも 谢谢/对不起 ごめんください 对不起，有人吗 お邪魔します 打搅 お邪魔しました 打搅了 失礼します 打搅了/告辞了 失礼しました 告辞了/失礼了 お先に失礼します 先告辞了 お疲れ様でした 辛苦了 ご苦労様でした 辛苦了 これからお世話になります 今后请多多关照 いつもお世話になっております 承蒙多方照顾 いろいろお世話になりましたよ 收到更方面的照顾 お久しぶりです 好久不见 ご無沙汰しています 久疏问候 お大事に 请保重 おかげさまで 托您的福]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>初级下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file对象什么的]]></title>
    <url>%2F2017%2F07%2F24%2Ffile%2F</url>
    <content type="text"><![CDATA[fileList对象和file对象html5 中的 input[type=’file’] 的标签有 multiple 属性，允许用户选择多个文件，fileList 对象则是保存了这些文件的列表，列表每一项都是一个 file 对象 属性 name ：文件名 type ：文件类型。图片类型可通过image/开头关键字限制只允许上传图片 size ：文件大小 lastModified ：文件最后修改时间 input:file 对象中还存在一个 accept 属性，可以用来规定能够通过文件上传进行提交的文件类型。 accept=”image/*” 可以用来限制只允许上传图像格式。但是在 Webkit 浏览器下却出现了响应滞慢的问题，要等上好几秒才弹出文件选择框。解决方法就是将 ‘‘ 通配符改为指定的 *MIME 类型。 应用多文件FileList链接请戳 多文件fileList 12345678910111213&lt;input type="file" id="files" accept="image/gif,image/jpeg,image/jpg,image/png" multiple&gt;&lt;script&gt; var elem = document.getElementById('files'); elem.onchange = function (event) &#123; var files = event.target.files; for (var i = 0; i &lt; files.length; i++) &#123; // 文件类型为 image 并且文件大小小于 200kb if(files[i].type.indexOf('image/') &gt; -1 &amp;&amp; files[i].size &lt; 204800)&#123; console.log(files[i].name + files[i].type); &#125; &#125; &#125;&lt;/script&gt; 文件预览链接请戳 文件预览1234567891011121314151617&lt;input type=&quot;file&quot; id=&quot;files&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;&lt;img src=&quot;blank.gif&quot; id=&quot;preview&quot;&gt;&lt;script&gt; var elem = document.getElementById(&apos;files&apos;), img = document.getElementById(&apos;preview&apos;); elem.onchange = function () &#123; var files = elem.files, reader = new FileReader(); if(files &amp;&amp; files[0])&#123; reader.onload = function (ev) &#123; img.src = ev.target.result; &#125; reader.readAsDataURL(files[0]); &#125; &#125;&lt;/script&gt; Blob对象表示一个不可变，原始数据的类似文件对象。区别于 mysql 的 blob 类型（二进制容器），html5 中的 blob 对象除了可以存储二进制数据之外，还可设置数据的 mime 类型，从某种程度讲，实现了文件的存储。而 html5 中的 file 对象则是基于 blob 对象继承扩展而来。 构造函数1Blob(blobparts[,options]) 所以需要关键字 new 来声明，旧式的 BlobBuilder 方法已经过时，不在讨论。1234&lt;script&gt;var blob = new Blob(["Hello World!"],&#123;type:"text/plain"&#125;);console.log(blob)&lt;/script&gt; 属性 isClosed：bool 是否为关闭状态，关闭状态的 blob 对象不可读 size：数据大小 type：字符串，表明对象包含数据的数据类型 方法close()关闭 blob 对象，释放底层资源 slice([start[, end[, contentType]]])返回一个新的包含源 blob 对象指定数据的 blob 对象 用法适用类型数组和blob创建一个url123456var typeArray = GetTheTypedArraySomehow();//mimevar blob = new Blob([typeArray], &#123;type:'application/octet-binary'&#125;);// 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串// 你可以像使用一个普通URL那样使用它，比如用在img.src上。var url = URL.createObjectURL(blob); 事实上我并没得到这样的字符串，我觉得我可能被骗了。。 Blob中提取数据123456唯一方法是使用FileReadervar reader = new FileReader();reader.addEventListener("loadend", function() &#123; // reader.result contains the contents of blob as a typed array&#125;);reader.readAsArrayBuffer(blob); 使用 FileReader 以外的方法读取到的内容可能会是字符串或是数据 URL。123456789&lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); var blob = new Blob(['C:/Users/Administrator/Desktop/DC93J54VYAEKSLs.jpg'], &#123;type:'image/png'&#125;) canvas.toBlob(function(blob)&#123; console.log(blob) &#125;)&lt;/script&gt; 通过url下载文件window.URL对象可以为BLob对象生成一个网络地址，结合a标签的download属性可以实现url下载文件。123456789createDownload("download.txt","download file")function createDownload(fileName, content)&#123; var blob = new Blob([content]); var link = document.createElement("a"); link.innerHTML = fileName; link.download = fileName; link.href = URL.createObjectURL(blob); document.getElementsByTagName("body")[0].appendChild(link);&#125; 我们知道，img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。 Ps：就先写到这，剩下几个demo再说，感觉这个东西没这么简单。2017年7月24日22点27分]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img fail那点事]]></title>
    <url>%2F2017%2F07%2F18%2Fimg-fail%2F</url>
    <content type="text"><![CDATA[img fail前言：据说，一个公司的网速决定着一个程序员的心情与产出，而网速决定着一篇文章裂图的程度。 告别裂图html 中的 img 标签预设了几个关于自身加载的事件： onError 图片加载出现错误，多数的处理是将图片路径指向默认图片 onLoad 图片加载完成之后触发事件 onAbort 图片加载过程中，用户手动停止加载（浏览器停止按钮）触发事件 前面也讲过，图片加载缓慢乃至加载失败并不全因为是网速问题，还有可能是图片服务器延迟，或者图片过期请求失效等。然后就会出现所谓的“裂图”,而这时 img 标签的 alt 属性就会发挥作用，提示用户当前加载失败图像的信息。如图： 然后从运行下面代码可以在控制台看到图片加载几个事件相应的输出。 12345678910111213141516&lt;script&gt;function loadSuccess() &#123; console.log('image load success!');&#125;function loadError() &#123; console.log('image load error!');&#125;function loadAbort() &#123; console.log('image abort!');&#125;&lt;/script&gt;&lt;div class="img-container"&gt; &lt;img src="http://1234.com/1.jpg" onload="loadSuccess()" onerror="loadError()" onabort="loadAbort()" alt="this is a fail img" /&gt;&lt;/div&gt; 显然这样的表现形式，在用户看来是非常不优雅的。身为一个程序员，如果所有异常分支没有做相应处理，就相当于一辆急速行驶的汽车，保不齐啥时候刹车会失灵一下下。 动手吧利用加载失败时的标签和伪类 :before :after 来做点事我们可以通过 :before :after 来定义加载失败的提示信息，例如在图片上方提示加载失败提示，下方提示图片的源地址。1&lt;img src="http://oi2fsv5ls.bkt.clouddn.com/twitter/Cwc6jkVUcAExIOI.jpg-orgi" alt="gakki-twitter" class="img_load img_load1"&gt; 12345678910111213141516171819202122232425.img_load&#123; position: relative; display: block; width: 100%; height: auto; font-family: 'Helvetica'; font-weight: 300; line-height: 1.5; text-align: center;&#125;.img_load1:before&#123; display: block; margin-bottom: 10px; content: "image load error !";&#125;.img_load1:after &#123; display: block; width: 100%; font-size: 12px; white-space:nowrap; overflow:hidden; text-overflow: ellipsis; content: "[url: " attr(src) "]";&#125; 然后图片加载失败就会显示成如下： 优化一下(算是)虽然上例已经展示了比较优雅的错误提示，和相应的图片源地址，保证用户能接受且能通过源地址来进行更加合理的访问。但是，裂图依旧在！来让我们弄点东西遮起来吧。本例采用了 font-awesome 库来实现小图标展示,所以需要先引进css库12&lt;link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;img src="http://oi2fsv5ls.bkt.clouddn.com/twitter/CwvqJsEUkAAyeiG.jpg-orgi" alt="gakki-twitter" class="img_load img_load2"&gt; 1234567891011121314.img_load2:after&#123; position: absolute; z-index: 2; top: -1px; left: 0; display: block; width: 100%; height: 100%; font-size: 16px; font-family: FontAwesome; background-color: #fff; color: rgb(100, 100, 100); content: "\f1c5" " " attr(alt);&#125; 图示如下： 总结基本网站开发框架都会集成默认图片，而且过大的图片对于网站加载速度不友好，所以这个的应用场景大概也就是寄存图床之类图片过期的博客或者论坛了。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式图片处理]]></title>
    <url>%2F2017%2F06%2F14%2FResponsive-Images%2F</url>
    <content type="text"><![CDATA[响应式图片处理 just note 固定宽度图像浏览器会根据设备像素比来选择加载图片 参数 srcset srcset 属性会罗列出当前可加载的备选图片，用逗号分隔。 不识别此属性的浏览器会直接加载 src 属性声明的图像。 x x 表示图像的设备像素比。 场景网站 logo 等宽度固定，大小不随着 viewport 的变化而变化 示例1234&lt;div class="img-box1"&gt; &lt;img srcset="images/gakki-540.jpg 1.5x,images/gakki-720.jpg 2x,images/gakki-1080.jpg 3x" src="images/gakki-360.jpg" alt="Responsive Images"&gt;&lt;/div&gt; 图片固定宽度为 300，浏览器通过识别设备像素比来筛选并加载图片。如上像素设备比为 2（例如：iphone6）的时候加载 gakki-720 的图片，3（iphone6 plus等）的时候会加载实际尺寸为 1080 的备选图。如果不支持，则默认加载 gakki-360。 点此查看示例 (建议新版本谷歌浏览) 可变宽度的图像浏览器会根据设备视窗大小( viewport )来选择加载图片 参数 srcset 备选图片列表，逗号分隔 sizes 包含两个值且用逗号分隔的图片展示规则列表，非必须。 如果 srcset 中使用了 w 描述符，则必须设置 sizes 属性。 第一个值为媒体查询条件，第二个为图片尺寸值，用 vw 来描述，不可使用百分比。 注：vw 兼容性不及 srcset 场景内容响应式图片处理 示例123456789&lt;div class=&quot;img-box2 &quot;&gt; &lt;img srcset=&quot;images/gakki-360.jpg 360w, images/gakki-540.jpg 540w, images/gakki-720.jpg 720w, images/gakki-1080.jpg 1080w&quot; sizes=&quot;(max-width: 400px) 100vw, (max-width: 960px) 75vw, 1080px&quot; src=&quot;images/gakki-1080.jpg&quot; alt=&quot;Responsive Images&quot;&gt;&lt;/div&gt; 浏览器会根据 sizes 定义的媒体查询条件来选择加载图片。例如网页宽度 600px 时，按照查询条件小于 960px,所以会按照 75% 加载，而 600*0.75 = 450 ,取最接近即 gakki-540 的图片。 点此查看示例 (建议新版本谷歌浏览) 不同的图像前两者都是通过 srcset 属性来实现同一图像不同质量的展示，而不支持此属性的浏览器会识别为普通的图像并加载 src 属性。 如果需要在不同的场景显示稍微不同的图片呢？例如大屏下显示全图，而小屏 or 移动端则仅需要展示细节，这样的场景需求则需要借用 picture 元素。 参数 source 定义媒体查询条件和备选图片地址 场景不同场景展示不同图片(全局细节之类的) 示例12345&lt;picture&gt; &lt;source media="(min-width: 960px)" srcset="images/gakki-large-1080.jpg"&gt; &lt;source media="(min-width: 575px)" srcset="images/gakki-mid-630.jpg"&gt; &lt;img src="images/gakki-small-360.jpg" class="picture-img" alt="Responsive Images"&gt;&lt;/picture&gt; 点此查看示例 (建议新版本谷歌浏览) 浏览器窗口的变化可见，图片在小屏下显示裁剪版的细节图。 不同类型的图像针对不同浏览器支持类型，渲染相应的格式的图片。新格式的图像在图片质量以及图片大小方面表现良好，但是目前来讲，兼容性待考验。 参数 source 指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源 源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的 img 元素。 场景不同格式的图片在文件大小和图片质量表现不一 ，不少新格式表现良好。chrome 和 opera 浏览器支持 webp 格式图像，而 jpeg-xr 格式则是微软专有格式，仅 ie 支持。 示例123456&lt;picture&gt; &lt;source type="image/vnd.ms-photo" src="images/gakki-875.jxr"&gt; &lt;source type="image/jp2" src="images/gakki-875.jp2"&gt; &lt;source type="image/webp" src="images/gakki-875.webp"&gt; &lt;img src="images/gakki-875.jpg" class="picture-img" alt="Responsive Images"&gt;&lt;/picture&gt; 查看示例(建议新版本谷歌浏览)ps：亲测，并没看到预料的结果，感觉被骗了.. 本文参考自 Using Responsive Images (Now).]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS webapp 踩屎记]]></title>
    <url>%2F2017%2F05%2F23%2Fios-webapp-issues%2F</url>
    <content type="text"><![CDATA[ios底部输入框遮挡 接上节，因为fixed元素的变现不友好，底部固定元素多采用了absolute定位。但底部固定元素内包含输入控件时，聚焦会发生输入框被键盘遮挡。 背景 场景 为了实现类 IM 即时通讯页面，输入框聚焦并紧贴键盘顶部浮起。 表现 某些浏览器会发生输入框遮挡被键盘遮挡。 qq内置以及微信内置浏览器估计对此作了些处理，基本没发现这种情况。 而别的浏览器，或多或少会复现这个问题（第一次触发） 理论上的表现为： 实际表现为： 分析输入框聚焦后，ios 和安卓对此作了不同的处理。安卓会对页面进行压缩，页面的 innerHeight 会发生变化，而ios会直接把页面向上推键盘的高度，页面的 innerHeight 并没发生变化（除了 UC 浏览器，真心不知道为什么这么另类）。查阅一些资料，发现了 Element 对象两个兼容性有待考量的方法 scrollIntoView() 和 scrollIntoViewIfNeeded()。 scrollIntoView() 让当前的元素滚动到浏览器窗口的可视区域内 语法 123element.scrollIntoView(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数 alignToTop 一个 Boolean 值： 如果为 true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为 false，元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions 一个 boolean 或一个带有选项的 object： 1234&#123; behavior: &quot;auto&quot; | &quot;instant&quot; | &quot;smooth&quot;, block: &quot;start&quot; | &quot;end&quot;,&#125; 如果是一个 boolean, true 相当于 {block: “start”}，false 相当于 {block: “end”} 兼容 详情点击 here. scrollIntoViewIfNeeded() 让当前的元素滚动到浏览器窗口的可视区域内 语法 12scrollIntoViewIfNeeded(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数 参数 alignToTop 一个 Boolean 值： 如果为 true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为 false，元素的底端将和其所在滚动区的可视区域的底端对齐。 兼容 详情点击 here. 然后，开始动刀，测试。 解决输入框聚焦，添加键盘呼起延迟，并对呼出键盘后的页面做输入框位置调整。 1234567891011121314151617181920212223242526272829var container = document.getElementById(&quot;wrapper&quot;); //最外部滚动容器var ele = document.getElementById(&quot;input_test&quot;);var eleDIv = document.getElementById(&quot;footer&quot;);var u = navigator.userAgent;var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端var isUc = u.indexOf(&quot;UCBro&quot;) &gt; -1;if(isiOS &amp;&amp; ele &amp;&amp; eleDIv)&#123; ele.onfocus = function()&#123; setTimeout(function()&#123; scrollDiv(); &#125;,isUc ? 350 : 200); &#125; &#125;function scrollDiv()&#123; var isChrome = u.indexOf(&quot;CriOS&quot;) &gt; -1; if(isChrome)&#123; document.body.scrollTop = container.clientHeight; //chrome 特殊处理 &#125;else if(Element.prototype.scrollIntoViewIfNeeded)&#123; eleDIv.scrollIntoViewIfNeeded(false); container.scrollTop = 1000; //切换输入法，首次等特殊情况补救 &#125;else if(Element.prototype.scrollIntoView)&#123; eleDIv.scrollIntoView(false); &#125;else&#123; document.body.scrollTop = container.clientHeight; //防止漏网之鱼 &#125;&#125; 吐槽： UC 两个方法都生效，不过呼出处理时间需要更久一点 chrome 也成功沦落到一个另类的表现，虽然自己公司 webapp 和谷歌表现一致 ios 原生 safari 浏览器的 UA 简直没法区分 Ps：这个方法可能不是最完美的解决方案，仅供参考，毕竟只是做个笔记。完整代码 请点击 。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记二]]></title>
    <url>%2F2017%2F05%2F15%2FRegExp-note2%2F</url>
    <content type="text"><![CDATA[抽风的电脑，字怎么变成繁体了。主要为正则对象函数的应用。 正则对象创建创建RegExp对象实例 显式构造: new RegExp(“pattern”[, “flags”]) 或 new RegExp(/pattern/[, “flags”]) 隐式构造: /pattern/[flags] 参数 pattern 正则表达式 flags 标志匹配规则。例如 “g” 全局匹配，”i” 不区分大小写，”m” 多行匹配等，常用的为 “g” 和 “i”。 正则函数应用RegExp对象test() 描述 检索字符串的指定值 语法 1exp.test(str) 参数 exp 正则对象 str 要检索的字符串 返回值 返回值为布尔类型，成功匹配则为 true ，反之 false 。 示例 123//检索字符串内是否存在&quot;abc&quot;var exp = /abc/;&apos;abcda&apos;.test(exp); //true exec() 描述 检索字符串的指定值 语法 1exp.exec(str) 参数 exp 正则对象 str 要检索的字符串 返回值 返回值为匹配到的值。若无匹配，返回 null 。 注：如果指定标志 g，可多次执行 exec() 查找成功匹配，查找位置从上一次查找的 lasetIndex 开始。 示例 123456789101112//多次执行exec()var patt1=new RegExp("o","g");do&#123;result=patt1.exec("Hello world!");console.log(result);&#125;while (result!=null)// ["o", index: 4, input: "Hello world!"]// ["o", index: 7, input: "Hello world!"]// null compile()将来的版本会被移除 web 标准，不再赘述。 String对象match() 描述 当一个字符串与一个正则表达式匹配时，match() 方法检索匹配项。 语法 1str.match(exp) 参数 exp 正则对象 如果 exp 传入的值为非正则对象，则会隐示调用 new RegExp(exp) 方法转换成正则对象。 如果 exp 传入的值为空，则返回结果为 [‘’]。 str 要检索的字符串 返回值 array。 包括匹配结果以及子表达式捕获结果的数组。如果未匹配，返回 null。 如果正则对象未指定 “g” ,返回结果同 RegExp.exec() ，且返回结果中拥有两个属性： index: 搜索结果索引值，input: 匹配的原始字符串。 如果指定了 “g” ,返回结果为所有匹配结果字符串的数组对象，而不是RegExp对象，且捕获结果不可获得。 示例 search() 描述 search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。 语法 1str.search(exp) 参数 exp 正则对象 str 要检索的字符串 返回值 匹配成功返回首次匹配结果的索引，否则返回 -1 . 示例 1234var str = 'Today is Sun.!';var result = str.search(/(sun\.)/i); //返回匹配结果的索引值result // 9 split() 描述 字符串对象分割成字符串数组，字符串分割成子串。 语法 1str.split(separator[, limit]) 参数 separator 字符串或正则对象，指定字符串分割的位置 limit 指定返回数组的最大长度。如果设定了 limit 值，返回数组的最大长度不超过 limit，否则不计长度，全部返回。 返回值 一个字符串数组，但不包括 separator 本身。 如果 separator 为包含子表达式的正则对象，那么返回数组中包括子表达式匹配的字符串，但不包含与整个正则表达式匹配的字符串。 注： 函数功能同Array.join()相反。 如果 separator 指定为 “”,则每个字符都会被分割。 示例 1234var str = "hello world! let's rock it.";str.split(/(!|\.)\s/) //分割两句话，且包括子表达式匹配结果//["hello world", "!", "let's rock it."] replace() 描述 字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 语法 1str.replace(exp|substr, replacement) 参数 exp|substr 子字符串或要替换的正则对象。如果为字符串，则优先按照字符串匹配。 replacement 字符串值。指定替换文本或者生成替换文本的函数 返回值 一个新的匹配替换完成的字符串。 注： replace() 实现的是查找并替换。如果正则对象指定了 g（全局标志），则会依次查找替换所有匹配项，否则只会查找替换第一个匹配项。 此外 replacement 参数中还有一个特殊的 $ 的特定用法(见文章结尾)。 示例 12345678910111213141516//颠倒字符串var myName = 'yao, somnus';myName.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1") //$1 $2 匹配两个捕获的子表达式// 'somnus, yao'//引号的替换var testStr = '"Tom" and "jerry"';testStr.replace(/"([^"]*)"/g, "'$1'") //依次匹配并替换 //'Tom' and 'jerry' //首字母大写转换var myName = 'yao, somnus';myName.replace(/\b(\w+)\b/g, function(name)&#123; return name.substring(0,1).toUpperCase()+name.substring(1); //通过生成替换文本函数完成文本替换&#125;)//Yao, Somnus 附：replace() 中 $ 的使用 语法 说明 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 正则表达式暂时就这么多了，笔记做完，心累，慢慢去撸demo了..]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记一]]></title>
    <url>%2F2017%2F05%2F15%2FRegExp-note1%2F</url>
    <content type="text"><![CDATA[心血來潮，又挖出正則表達式，順便整理下筆記。 元字符常用的元字符： 语法 说明 \b 匹配字边界 \B 匹配非字边界 \d 匹配数字字符 \D 匹配非数字字符 \w 匹配A-Z，a-z，0-9和下划线 \W 匹配除以上任意 特殊字符特殊字符的匹配需要进行转义，字符前添加 “\” 语法 说明 * 零次或多次匹配前面的字符或表达式 + 一次或多次匹配前面的字符或表达式 ? 零次或一次匹配。若紧随其他限定符则匹配非贪婪模式 ^ 匹配字符串开始的位置。若用作括号表达式第一个字符贼会对字符集取反 $ 匹配搜索字符串结尾的位置 . 匹配除换行符 \n 之外的任意单个字符 [ ] 标记括号表达式的开始和结尾 { } 限定表达式的开始和结尾 ( ) 子表达式的开始和结尾。可保存子表达式以备将来使用 &#124; 候选项表达式匹配 / JScript 中的文本正则表达式模式的开始和结尾，后一个 ‘/‘ 后添加单字符标志可指定搜索行为。g(全局) i(忽略大小写) \ 将下一字符标记为特殊字符文本。反向引用或八进制转义字符 非打印字符 语法 说明 \f 换页符 \n 换行符 \r 回车符 \v 垂直制表符 \t Tab 符 \s 任意空白字符 \S 任意非空白字符 贪婪与懒惰模式正则中包含能接受的重复的限定符时，通常行为是尽可能匹配更多的字符。 例如: a.*b 限定符在贪婪模式下会尽可能匹配更多的字符。a.*b 会匹配字符串 acbab 的 acbab 而不会匹配 acb。 有时我们需要匹配尽可能少的字符，这时我们需要在限定符后添加 ? 。例如：a.*?b 会匹配到 acbab 的 acb 和 ab 。 懒惰限定符: 语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 反向引用子表达式匹配的文本即此分组捕获的内容能在表达式以及程序中作进一步的处理。 子表达式用括号限定符来声明。 (a.b)c 中 (a.b) 则声明了一个子表达式，子表达式的内容可以捕获。而子表达式匹配的内容则可视作一个分组。 默认情况下，每个分组都拥有一个组号，从左到右，以子表达式的左括号为标志，第一组为1，依次递增。 反向引用用于重复搜索前面某个分组匹配的文本，语法为: +组号或组名 “\1” 。 例如：搜索不正确的变量声明 var var a = ‘hello’; \b(\w+)\b\s+\1\b 为例，(\w+) 分组匹配内容, \1 分组捕获内容。 或者可以自己指定组名 语法: (?&lt;name&gt;\w+) 或 (?’name’\w+) name 即为组名称。 反向引用这个组捕获内容，语法: \k&lt;name&gt; 所以上面的例子也可以写作: \b(?\w+)\b\s+\k\b 其次还有几种特殊用法: 分类 代码/语法 说明 内容捕获 (exp) 匹配exp并捕获到自动命名的组中 内容捕获 (?exp) 匹配exp并捕获到name命名的组中 内容捕获 (?:exp) 匹配exp不捕获也不分配组 零宽断言 (?=exp) 匹配exp前面位置 零宽断言 (?&lt;=exp) 匹配exp后面位置 零宽断言 (?!exp) 匹配后面不是exp的位置 零宽断言 (?&lt;!exp) 匹配钱面不是exp的位置 注释 (?#comment) 提供注释，方便阅读 零宽断言用于查找某些内容（但不包括自身）之前或者之后的东西，也就是说他们指定一个位置，而这个位置满足一定的条件（即断言），故称为零宽断言。 (?=exp) 零宽度正预测先行断言 断言自身出现的位置的后面能匹配表达式exp 例如： \b\w+(?=img\b) 匹配以img结尾的单词的前面部分(不包括 img ) (?&lt;=exp) 零宽度正回顾后发断言 断言自身出现的位置的前面能匹配表达式exp (?&lt;=\bexp)\w+\b 匹配 exp 开头的单词的后半部分(不包括 exp ) (?:exp) 零宽度负预测先行断言 断言此位置的后面不能匹配表达式 exp \d{3}(?:\d) 匹配后面不为数字的三位数 (?&lt;:exp) 零宽度负回顾后发断言 断言此位置出现的前面不能匹配子表达式 exp (?&lt;:0)\d{7} 匹配前面非 0 的 7 位数字 注释通过 (?#comment) 来包含注释，方便阅读。 优先级正则表达式的匹配优先级：从左到右，并遵循优先级顺序。从上到下优先级依次降低。 代码 说明 \ 转义符 () (?:) (?=) [] 括号，中括号 * + ? {n} {n,} {n,m} 限定符 ^ $ \任意字符 定位点和序列 &#124; 替换选项]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-start%2F</url>
    <content type="text"><![CDATA[脑子一热一抽筋把家里电脑换了个硬盘，重做了个系统.. 起因重装系统遇到阻碍，无奈格掉了硬盘，代之前的十几篇就随风而去了 解决还是原来的配方，不过已经变了味道。在原先的博客分支添加了一个hexo分支用作本地未编译代码的备份，而另一个master分支则用于博客编译文件的push分支。so，妈妈再也不担心我的代码因为各种原因丢失了。 待做趁着这次机会算是让我好好的了解了一下github ssh同步代码的流程。然后接下来就是单纯做个计划，计划下后来的几篇的内容。 github 入门使用指南（单就常用的吧） atom编辑器初尝心得与插件之类 git命令使用（公司办公一直GUI操作，总感觉自己是个假的git使用者） 内存管理，执行上下文，this，作用域作用域链，原型原型链之类（一直有再看，但是总感觉没入门，不能给别人讲清楚就算没懂吧） 整理一下正则表达式的笔记 等等最近日语学的整个人有点发懒，都五月份了才想起改该好好学习了，惭愧..]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES5新增数组方法]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-array-func-es5%2F</url>
    <content type="text"><![CDATA[ES5新增数组方法 ES5新增数组方法学习笔记。 Foreach接收一个函数作为参数，对数组进行循环遍历，而并不改变数组。 语法12345array.forEach(callback(currentValue, index, array)&#123;&#125;,this)array.forEach(callback[, thisArg]) 参数forEach方法会对数组的有效值的每一项执行callback函数，已经删除或者未初始化的项会被跳过。而callback函数会被传入三个参数： 数组当前项值 当前项的索引 数组对象本身 1234567891011121314151617var arr = ['a','b','c','d'];arr.forEach(console.log);//循环遍历功能等同于for(var i = 0; len = arr.length,i &lt; len; i++)&#123; console.log(arr[i]);&#125;//期望输出a 0 ["a", "b", "c", "d"]b 1 ["a", "b", "c", "d"]c 2 ["a", "b", "c", "d"]d 3 ["a", "b", "c", "d"]abcd 区别就在于forEach回调返回了三个参数，如图 而array.forEach(callback[, thisArg])方法中thisArg参数是可选的，如果指定则在执行回调时用作this的值，否则默认传入undefine。 兼容polyfill作为ES5新增方法，难免有些浏览器不支持，所以当我们使用时需要添加一段代码来帮助它兼容旧环境（polyfill）,代码来自MDN。123456789101112131415161718192021222324252627282930313233if (!Array.prototype.forEach) &#123; Array.prototype.forEach = function (callback,thisArg) &#123; var T, k; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; k = 0; while (k &lt; len) &#123; var kValue; if (k in O) &#123; kValue = O[k]; callback.call(T, kValue, k, O); &#125; k++; &#125; &#125;&#125; 注意forEach无法在所有有效元素传递给回调函数之前终止（而for循环有break方法），如需提前终止，需要把forEach置于try语句块中，并抛出异常。 Map用法同forEach基本相同，区别在于map方法返回一个新数组 语法1const new_array = arr.map(callback[, thisArg]) 参数略. 实例略. 兼容polyfill区别于forEach():123456789101112131415//创建新数组var A = new Array(len);...//保存callback返回值mappedValue = callback.call(T, kValue, k, O);// 返回值添加到新数组A中.A[ k ] = mappedValue;... //返回新数组Areturn A; Everyevery()接收一个返回值布尔类型的函数。 语法1arr.every(callback[, thisArg]) 参数every方法为数组的每一项执行callback函数，不会改变原数组。如果所有项callback函数返回为true，则方法返回true，如果遇到一个返回值为false，则直接终止并返回false。同样，callback方法只对那些有效值的项进行操作。callback被调用传入三个函数： 元素值 元素索引 数组对象本身 实例检测是否为奇数12345678function isOdd(ele, index, arr)&#123; return (ele % 2 == 1);&#125;var arr1 = [1,5,6,9,12].every(isOdd);//falsevar arr2 = [1,3,5,7,9,11].every(isOdd);//true 兼容polyfill1234567891011121314151617181920212223242526if (!Array.prototype.every)&#123; Array.prototype.every = function(callback, thisArg)&#123; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var T = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; var thisArg = arguments.length &gt; 1 ? thisArg : null; for (var i = 0; i &lt; len; i++) &#123; if (i in t &amp;&amp; !fun.call(thisArg, t[i], i, t)) return false; &#125; return true; &#125;;&#125; Some用法同every()基本相同，区别在于只要有一项callback函数返回值为true则方法返回true，否则为false。 语法1arr.some(callback[, thisArg]) 参数略. 实例略. 兼容polyfill略.区别只在于return值取反 reduce接受一个回调函数作为累加器，数组中每个值开始缩减，最终为一个值，是ES5中新增的一个数组逐项处理方法。reduce直译是缩减减少，函数定义以及实现个人感觉更像是递归。 语法1arr.reduce(callback[, initialValue]) 参数reduce方法接收一个函数类型的回调函数和一个可选初始值参数 callback 数组每一项的回调函数，接受4个参数 accumulator 上一次调用的返回值或者初始值 currentValue 正在处理的数组元素 currentindex 正在处理的数组元素索引 array 数组元素本身 initialValue 可选初始值参数，第一次调用传给accumulator 回调函数第一次执行时，有两种情况，如果initialValue指定，则accumulator取值为initialValue，currentValue取值数组第一项，如果没有指定initialValue，accumulator取值数组第一项，而currentValue取值数组第二项。 如果数组为空且没有提供initialValue，会抛出TypeError错误，如果仅有一个元素且没提供initialValue或者提供了initialValue数组为空，则直接返回，不会调用callback。 实例数组求和，数组扁平化，计算数组中值出现次数1234567891011121314151617181920212223242526272829//求和var arr = [1, 2, 3, 4];arr.reduce(function (pre, cur) &#123; return pre + cur;&#125;,10);//20//扁平化var newArr = [[1, 2], [3, 4], [5, 6]].reduce(function(pre, cur)&#123; return pre.concat(cur);&#125;,[]);//[1, 2, 3, 4, 5, 6]//计算重复值次数var arr = ['Alice', 'Bob', 'Ciel', 'Dianel', 'Alice', 'Ciel', 'Alice'];arr.reduce(function(newObj ,key)&#123; if(key in newObj)&#123; newObj[key]++; &#125;else&#123; newObj[key] = 1; &#125; return newObj;&#125;,&#123;&#125;);//&#123;Alice: 3, Bob: 1, Ciel: 2, Dianel: 1&#125; 兼容polyfill一如既往地代码来自MDN123456789101112131415161718192021222324252627282930313233343536373839if (!Array.prototype.reduce)&#123; Array.prototype.reduce = function(callback /*, initialValue*/) &#123; 'use strict'; if (this === null) &#123; throw new TypeError('Array.prototype.reduce called on null or undefined'); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = 0, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in t)) &#123; k++; &#125; if (k &gt;= len) &#123; throw new TypeError('Reduce of empty array with no initial value'); &#125; value = t[k++]; &#125; for (; k &lt; len; k++) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; Filter同every()方法类似，回调函数参数相同，返回值为回调参数结果为true的所有项集合的数组。 语法1arr.filter(callback[, thisArg]) 参数filter为数组中每一个有效值项调用callback函数，返回一个新数组，数组内容是callback返回值为true的元素的集合。 实例筛选奇数123456function isOdd(ele)&#123; return ele % 2 == 1;&#125;[1, 54, 23, 44, 13].filter(isOdd);//[1, 23, 13] 兼容polyfill12345678910111213141516171819202122232425262728293031323334if (!Array.prototype.filter)&#123; Array.prototype.filter = function(fun)&#123; if (this === void 0 || this === null) throw new TypeError(); var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== "function") throw new TypeError(); var res = []; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t) &#123; var val = t[i]; // NOTE: Technically this should Object.defineProperty at // the next index, as push can be affected by // properties on Object.prototype and Array.prototype. // But that method's new, and collisions should be // rare, so use the more-compatible alternative. if (fun.call(thisArg, val, i, t)) res.push(val); &#125; &#125; return res; &#125;;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
</search>
