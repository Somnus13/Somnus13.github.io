<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iPhone X 适配]]></title>
    <url>%2F2018%2F02%2F13%2Fiphone-x%2F</url>
    <content type="text"><![CDATA[这篇文章迟到了很久，暂且记录一下自己遇到的坑 html5网页因为目前就职公司采用的H5响应式驱动的主体项目，app都是基于的webview开发，当iPhone X上市后，适配促成了新的兼容任务。 新属性为了更好的适配iPhone X，iOS 11新增了几个特性用于处理那诡异的刘海屏。苹果公司还对iPhone X的屏幕内容作了安全距离限定，美其名曰为了更好的用户体验，其实就是为了填自己的坑。。 viewport-fitiOS11新增特性，为了适应iPhone X对现有的viewport meta标签的一个扩展，定义网页在可视窗口的布局方式。safari浏览器中开发模式可勾选支持调试。属性： contain：可视窗口包含网页内容，即内容会在安全区域显示 cover：网页内容覆盖可视窗口 auto： 默认值，同contain表现是一致的 详情见文档 constantiOS11新增特性，webkit的css函数，用于设定安全区域与边界的距离，有四个预定义变量。 safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 我们需要关注的就是safe-area-inset-bottom，对应也就是底部小黑条的处理同时需要注意的就是，viewport-fit 为contain时，constant函数是不起作用的，需要配合cover使用，不支持constant 的浏览器会被忽略此属性 其实有些人会有些疑惑，很明显设计稿下面空出的距离就是68像素（2倍设计稿），但是网页适配你要兼容旋转屏幕，所以乖乖用人家的不要闹。 env（iOS 11.2后支持，兼容处理）这是当初比较坑的一点，同事的突然一波更新，整个人陷入绝望，窝草！说好的适配呢，都不生效了！！后来又查了查，哦，11.2以后支持这个属性了，constant废除了。。可定义的值并无任何变化，只是函数名变了，略。 适配方案官方给的建议就是，列表或者内容建议通底显示，黑条压了就压了，反正可以滑动内容，至于底部有悬浮固定操作的交互时候，建议做兼容处理。 设置网页窗口的布局方式 viewport meta标签添加 viewport-fit=cover属性 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt; 页面内容主体限定安全区域 为了避免列表尾项或者主体内容受到小黑条遮挡，我们需要对body做一些处理 123456body &#123; /* iOS 11.0 */ padding-bottom: constant(safe-area-inset-bottom); /* 11.2+ */ padding-bottom: env(safe-area-inset-bottom);&#125; 底部悬浮交互按钮 一般大多数需要做兼容处理的就是这种，web应用的底部导航菜单。 我们需要对吸底按钮做内边距处理，增加扩展高度，注意吸底元素最好设置个背景色，不然会镂空网站主体背景色 123456&#123; /* iOS 11.0 */ padding-bottom: constant(safe-area-inset-bottom); /* 11.2+ */ padding-bottom: env(safe-area-inset-bottom);&#125; 或者通过css的计算函数calc来增加高度 1234&#123; height: calc(50px(预设值) + constant(safe-area-inset-bottom)); height: calc(50px(预设值) + env(safe-area-inset-bottom));&#125; 除此之外，有些悬浮按钮也需要处理，例如返回顶部之类，同样的通过计算函数增加定位元素的bottom值 1234&#123; bottom: calc(50px(预设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(预设值) + env(safe-area-inset-bottom));&#125; 需要注意的是：calc 属性计算中间的空格不可忽略，代码压缩会有点坑此处 属性兼容处理support 我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 实现： 123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; fixedDiv &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 小程序小程序的处理相对就比较无脑，通过或许手机信息接口拿到是否为iPhone X,然后做相应的样式处理123456789// 获取手机信息wx.getSystemInfo(&#123; success: function (res) &#123; let model = res.model.substring(0, res.model.indexOf(&quot;X&quot;)) + &quot;X&quot;; if (model == &apos;iPhone X&apos;) &#123; that.globalData.isIpx = true &#125; &#125;&#125;) 注意：小程序webview中的适配采用h5的网页适配属性不生效，需要通过参数传递然后动态添加class做样式处理 app如果业务逻辑是由app驱动，直接甩好webview距离就好，如果是web驱动，建议移交web来做底部兼容 后话大过年的在家懒了好几天终于开始用笔记本干正事系列。。(碎碎念，讲道理浏览量这么少的东西，我就没必要定性自己写的是技术博客了)]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 下面那些让人抓狂的东西]]></title>
    <url>%2F2017%2F10%2F08%2Fwindows-about%2F</url>
    <content type="text"><![CDATA[作为一个混迹windows的程序员，没事重装一下电脑简直和吃饭一样简单，但是每次装完都会被有些东东恶心到。。 系统重装开机的无效索引装完系统，如果是u盘安装之类的话，大都会多出一个无效索引，也就是旧系统的索引，不能忍！ Win + R 键入 msconfig，打开系统配置 点击 “引导” 菜单进行管理，删除无效项即可 window.old文件夹删除“Windows.old” 文件夹包含升级win10前系统的 “Windows”、“Program Files”、“Users”这三个目录中的文件，将之前的系统文件和安装的程序文件都做了备份。这是微软出于人性化的考虑，让没有来得及备份重要文件的用户可以再次选择备份。对不起，我不打算考虑！ 系统盘右键 - 属性 - 磁盘清理 扫描完成 - 清理系统文件 列表中勾选”以前的Windows安装”，确定，待完成退出 dll库errorMSVCR10.dll曾经困扰我多次的东东，每次都要百度一下，捉急！安装对应版本的VC库 vcredist_x64.exe 和vcredist_x86.exe下载地址：vcredist.exe 软件errorchrome熟悉的提示：“Google Chrome 未响应。是否立即重新启动”，选项给你的选择并不能解救你。 Win + R 输入 cmd 打开命令行 输入 taskkill /f /im chrome.exe ,回车执行 重新打开Google Chrome Wampserver经常本地 demo 手机测试都会暂时用它架一个静态服务器，之前 php 学习用的工具，但 php 早忘光了。安装完成不做一点配置的话就会出现手机访问 403，做个备份省的再查。 关闭防火墙 修改 apache 目录下的 httpd.conf文件 12//path: apache\apache2.4.17\conf\httpd.conf 291行左右修改 Require local =&gt; Require all granted 修改 httpd-vhosts.conf 文件 12//path: 目录下搜索 httpd-vhosts.conf 找到 &lt;VirtualHost *:80&gt;节点上的所有虚拟站点修改 Require local =&gt; Require all granted 重启服务 注：此方法仅支持2.4以后的版本 百度云说不上是错误，但是着实恶心，安装完百度云自动帮你在我的电脑添加一个“百度云管家”的盘符快捷方式，真心逼死强迫症。打开百度云，设置 - 基本 - 在我的电脑中显示百度云管家，默认是勾选状态，去除勾选 - 应用 - 确定。如果成功，下面的可以无视。 Win + R 键入 regedit 进入注册表编辑 依次展开 HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ Explorer \ MyComputer \ NameSpace，删除 NameSpace 下面的 {679F137C-3162-45da-BE3C-2F9C3D093F64} 项 若无，跳至第4步。 在 NameSpace 项上点右键 - 权限，依次操作 - 高级 - Administrators - 编辑 - 创建子项 - 拒绝 依次展开 HKEY_CURRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Explorer \ MyComputer \ NameSpace ，删除 {679F137C-3162-45da-BE3C-2F9C3D093F64} 项 退出刷新。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Repaint/Reflow到css选择器]]></title>
    <url>%2F2017%2F10%2F05%2Fcss-seletor%2F</url>
    <content type="text"><![CDATA[什么是Repaint/Reflow?先扒一张图，来解释下浏览器的工作流程 上图可归纳为四步： 解析构建 DOM 树 渲染引擎开始解析 html 文档，转换树中的标签或者生成的标签到 DOM 节点，这时的它称为内容树 构建渲染树 解析所有 CSS,并据此计算节点样式，创建渲染树 布局渲染树 从根节点递归调用，计算元素的大小位置，并把每个节点放在该出现的精准坐标位置 绘制渲染树 遍历渲染树，每个节点使用 UI 后端层绘制 从以上不难看出，Repaint 和 Reflow 发生在了第三四步，故给出定义：浏览器在解析页面时，根据 css 以及 js来计算并把相应的元素置于该出现的位置，这个过程就是 Reflow;当元素的位置大小颜色确定后，浏览器会按照各自的属性进行绘制，这个过程就是 Repaint。故我们需要避免引发此类操作，以此来提高渲染速度。 引起Repaint/Reflow的一些操作Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 如何优化Reflow是不可避免的，只能将Reflow对性能的影响减到最小,给出下面几条建议： 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className： 1234567// 不推荐的写法var left = 10,top = 10;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;;// 推荐写法el.className += &quot; theclassname&quot;; 把 DOM 离线后修改。如： a&gt; 使用 documentFragment 对象在内存里操作 DOM。 b&gt; 先把 DOM 给 display:none (有一次 repaint)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。 c&gt; clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是会大大减小 reflow 。 尽量不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 css选择器 上面提到了Repaint和Reflow，以及如何优化的问题。我们知道浏览器工作流程第三步就是解析css然后计算元素位置并放置，那么如何从这点上来提高效率呢？这就要提到css的渲染效率了，下面我们来探讨下。 浏览器如何识别你的选择器浏览器读取你的选择器，遵循的原则是由右向左读取，换句话讲，读取选择器会由右向左进行。举个栗子：1div.header &gt; ul li p 上述选择器，浏览器会尝试在你的 html 标签中寻找 p 元素,接着匹配 li 和 ul，最后再去匹配 div.header,所谓的由右到左就是这样。 选择器的最后一部分，也就是最右边的部分被称为 关键选择器，而它决定着你的选择器效率的高低。而关键选择器的作用就是提高选择器的效率，每少检查一个给定的规则，就会更有效的将样式匹配给对应的html元素。所以我们的方向就是让关键选择器更加有效性能化更高，那么如何实现呢？很简单，关键选择器越具体，性能化就越高。 选择器效率如果你是个合格的前端开发者，对 css 选择器有一定了解的话，应该对那些选择器以及它的优先级不会太陌生。来让我们看下 Steve Souders 大神给的优先级排序： id选择器 (#id) 类选择器 (.class) 标签选择器 (h1,div,p..) 相邻选择器 (h1+p) 子选择器 (div &lt; span) 后代选择器 (div span) 通配符选择器 (*) 属性选择器 (a[rel=’’]) 伪类选择器 (a:hover,li:nth-child(1)) 上述选择器优先级按照降序排列，当然还有上面你没提到的行内样式和 !important，建议还是少用为妙，毕竟对于维护来讲太恶心。 书写高效的css选择器来自Mozilla的几点建议（搬运工）David在《Use efficient CSS selectors》中介绍了几种书写高效率的CSS选择器的方法: 避免普遍规则 不要在 ID 选择器前加标签名或类名 不要在类名选择器前加标签名 尽可能使用具体的类别 避免使用后代选择器 标签分类规则中不应该包含一个子选择器 子选择器的问题 借助相关继承关系 使用范围内的样式表 一些降低渲染资源消耗的实战经验 十六进制颜色值对位数与大小写 默认标准是大写以及 6 位数标注，建议书写规范，虽然未有确实数据表明不采用写法会对渲染速率有影响。 display 与 visibility 差异 两者均用于设置或检索是否显示对象。前者隐藏对象且不保留物理空间，而后者会保存物理空间。浏览器渲染被占据的物理空间时，会有所消耗。建议采用 display:none; border:none; 与 border:0;区别 区别同上, border:0; 把 border 设为 “0” 像素虽然在页面上看不见，但按 border 默认值理解，浏览器依然对 border-width/border-color 进行了渲染，即已经占用了内存值。 border:none; 把 border 设为 “none” 即没有，浏览器解析 “none” 时将不作出渲染动作，即不会消耗内存值。 建议使用border:none; 不宜过小的图片平铺 一张宽高 1px 的背景图片，虽然文件体积非常之小，但渲染宽高500px的板块需要重复平铺 2500 次。提高背景图片渲染效率跟图片尺寸及体积有关，最大的图片文件体积保持约 70KB。建议采用衡量适中体积及尺寸的背景图片 IE的滤镜 IE的滤镜除了比较消耗资源外也有兼容性问题。当中有令 PNG 透明的滤镜，可采用 GIF 或 JPG 似透非透的办法来避免使用此滤镜。建议只在 IE6 应用 GIF 透明，因为 IE7 以上已经支持了 PNG 透明。 通配符*{margin:0;padding:0;} 号通配符把所有标签都初始化一遍，浏览器的渲染消耗一定的资源。有部分在标签在不同浏览器上几乎无差异，或是某些已经不推荐使用的标签(因为你不会去用它)，它们不需通配符要重新初始化一遍这样做能节省一点资源。 推荐方案(代替 reset )：normalize.css(如果没听说过自行百度) 不要添加额外的标签来描述 class 或 id 如果你有一个选择器是以 id 作为关键选择符，请不要添加多余标签名上去。因为 ID 是唯一的，你不要为了一个不存在的理由而降低了匹配的效率。 不赞成 - button#backButton { } 不赞成 - .menu-left #newMenuIcon { } 建议用 - #backButton { } 建议用 - #newMenuIcon { } 尽量选择最特殊的类来存放选择器 降低系统效率的一个最大原因是我们在标签类中用了过多的选择符。通过添加 class 到元素，我们可以将类别进行再细分为 class 类，这样就不用为了一个标签浪费时间去匹配过多的选择符了。 不赞成 - treeitem[mailfolder=”true”] &gt; treerow &gt; treecell { } 建议用 - .treecell-mailfolder { } 避免子孙选择符 子孙选择符是 CSS 中最耗资源的选择符。他真的是非常的耗资源，尤其是在选择器使用标签类或通用类的时候。很多情况中，我们真正想要的是子选择符。除非有明确说明，在 UI CSS 中是严禁使用子孙选择符的。 不赞成 - treehead treerow treecell { } 好一点，但还是不行(参照下一条) - treehead &gt; treerow &gt; treecell { } 标签类中不要包含子选择符不要在标签类中使用子选择符。否则，每次元素的出现，都会额外地增加匹配时间。（特别是当选择器似乎多半会被匹配的情况下） 不赞成 - treehead &gt; treerow &gt; treecell { } 建议用 - .treecell-header { } 留意所有子选择符的使用小心地使用子选择符。如果你能想出一个的不使用他的方法，那么就不要使用。特别是在 RDF 树和菜单会频繁地使用子选择符，像这样。 不赞成 - treeitem[IsImapServer=”true”] &gt; treerow &gt; .tree-folderpane-icon { } 请记住 RDF 的属性是可以在模板中被复制的！利用这一点，我们可以复制那些想基于该属性改变的子 XUL 元素上的 RDF 属性。 建议用 - .tree-folderpane-icon[IsImapServer=”true”] { }. 暂时就这么多了，国庆在家没网，更个东西也是费死个老劲。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC(Block Formatting Content)]]></title>
    <url>%2F2017%2F09%2F19%2Fbfc%2F</url>
    <content type="text"><![CDATA[What is BFC? BFC 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 当涉及到可视化布局的时候，BFC 为我们提供了一个环境，这个环境规定着其布局的规则，而不同环境之间的布局不会相互影响。想要更好的理解这个概念，需要先理解 Box 和 Formatting Context 的概念。网页的布局核心就是盒子的组成排列，这些盒子就是 Box。盒子的类型和 display 属性决定着这个 Box 的类型。不同类型的 Box，会参与不同的 Formatting Context（决定如何渲染文档的格式结构），然后其内元素就会以不同方式渲染。例如： block-level box ：display 属性为 block, list-item, table 的元素，会生成 block-level box， 并参与 block formatting context; inline-level box：display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box， 并参与 inline formatting context 而 Formatting Context 是一块渲染区域，它决定着其子元素如何定位，以及与其他元素的位置关系。通过上面一些概念，建议把 BFC 简单理解为一种属性，在具有此属性的容器中，元素按照 BFC 的规则实现布局。比如浮动元素会形成 BFC，这就是为什么我们看到浮动元素布局跟普通文档流的布局有所差别的原因。 规则是什么呢简单以下几条规则，理解起来不太难。 内部的 box 元素会在垂直方向依次放置，也就是文档流的从上而下 垂直方向距离由 margin（外边距）决定 其内每个元素的 margin box 的左边和包含块 border box 的左边相接触（由右向左的格式化则相反），浮动也如此 BFC 的区域不会与其内浮动元素发成重叠 BFC 就是页面一个隔离的独立容器，内联元素不会对外面元素产生影响，反之亦成立 计算 BFC 高度的时候，浮动元素也参与计算 哪些元素会生成 BFC 根元素 浮动元素，float 属性不为 none 绝对定位元素，position 属性为 absolute 或 fixed（absolute的子类） display 属性为 inline-block，table-cell，table-caption，flex，inline-flex overflow 属性不为 visible 以外值的 css3 中，BFC 叫做 Floe Root，并增加了一些触发条件 BFC 在布局中的作用 解决两元素 margin 重叠问题。 要想两个相邻元素不发生垂直方向的 margin 重叠，需要将他们定义在不同的 BFC 中。解决方法即在其中一个元素外包裹一层元素 ，再对包裹元素进行 BFC 触发（声明以上触发 css 属性）。 解决由于浮动造成的重叠问题。 一般情况下，浮动元素会脱离文档流，即不占用位置。它的性地元素会与它在左上角重叠，但如果两个相邻元素都设置了浮动，那么意味着它们都会以 BFC 的规则渲染，据以上第四条规则，BFC 区域不会相互重叠，所以为什么浮动元素独占空间便能理解了 解决容器由于拥有浮动元素造成的高度塌陷 普通容器中，如果里面有浮动元素，且不设置高度的情况下，容器的高度是无法被撑起的。这时可通过设置 overflow 属性为 hidden 将之声明为 BFC，那么就可以包含浮动元素了]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语初下复习（25-26）]]></title>
    <url>%2F2017%2F08%2F28%2Fnihongo25-26%2F</url>
    <content type="text"><![CDATA[25.これは明日会議で使う資料です 动词（简体形）+ 名词 小句（动词简体形）+ 名词表示某种习惯或将要发生的动作用基本型，如果是已经玩成的动作用 “た形”1これは 明日会議で使う 資料です。 小句（动词简体形）+ 名は 名/形 です动词小句修饰名词形成的名词短语做主语1私が 明日乗る 飛行機は中国航空です。 小句（动词简体形）+ 名を/に/から 动ます动词小句修饰名词形成的名词短语做主语以外的其他部分1中国で買ったCD を 友達に貸しました。 小句（一类形/二类形/名）+ 名一类形容词修饰名词用 基本型，二类形容词修饰名词 + “な“ 修饰，名词修饰名词用 “の“ 修饰123入り口が 広い あの建物は私の会社です。 操作が 簡単な パソコンが欲しいです。 数学が 専門の先生 が休みました。 扩展单词 假名 释义 假名 释义 假名 释义 假名 释义 うえ 上 上面 した 下 下面 なか 中 里边，内部 そと 外 外面 まえ 前 前面 うしろ 後ろ 后面 ひだり 左 左面 みぎ 右 右面 よこ 横 侧面 そば 側 旁边 むかい 向かい 对面 まわり 周り 周围 あいだ 間 中间 すみ 隅 角落 ました 真下 正下方 きた 北 北面 みなみ 南 南面 ひがし 東 东面 にし 西 西面 26.自転車に二人で乗るのは危ないです 小句（动词简体形）+ のは + 形 です动词小句加 “の“ 使其名词化，表示”做某动作“的意思。名词化做主语，谓语为表示性质状态的一类或二类形容词时，主语用助词 “は“12自転車に二人で乗るのは危ないです。パソコンで表を作るのはたのしいです。 如果名词形式为 表示好恶、擅长不擅长之类的对象 时，用助词 “が“ 修饰名词12李さんは絵を書くにが好きですね。はい、色鉛筆でスケッチするのが大好きです。 此外，如果 好恶、擅长不擅长之类的对象当做话题 来讨论，助词用 “は“12絵を書くのは好きですか。いいえ、絵を書くのは嫌いです。 小句（动词简体形）+ の + を + 动词动词小句加 “の“ 的名词化形式可以做宾语。12手紙を出すのを忘れました。森さんが発言するのを聞きまし。 这种名词化形式做宾语时 “の“ 和 “こと“ 可以互换例外： 句尾动词为 しらせます（告诉） 伝えます（转告） 話します（说）等表示 语言行为 的动词时，要用 “こと“ 而不能用 “の“ 1李さんは森さんが休むことを伝えました。 句尾动词为 見ます（看） 聞きます（听） 等表示 感知动作 的动词或 手伝います（帮忙） やめます（停止） 防ぎます（防御） 等表示 直接动作对象 的动词，则使用 “の“ 而不能用 “こと“ 12李さんは森さんが車から降りるのを見ました。李さんは森さんが荷物を運ぶのを手伝いました。 小句（简体形） でしょう [推测]表示说话人对自己和听话人都不能断定的事进行推测，常与 “たぶん“ 呼应使用。动词小句和一类形容词小句用简体形后续 “でしょう“,二类形容词小句和名词小句则把简体形的 “だ“ 换成 “でしょう““でしょう“ 的简体形是 “~だろう“12345明日の朝は大雨になるでしょう。森さんは知らないでしょう。この本の値段は分かりませんが、たぶん高いでしょう。今年はたぶん豊作だろう。これはたぶん誰かの忘れ物だろう。 小句（简体形）かもしれません表示有可能发生某事，其可能性在百分之五十左右。动词小句和一类形容词小句用简体形后续 “かもしれません“,二类形容词小句和名词小句则把简体形的 “だ“ 换成 “かもしれません“12森さんは今日会社を休むかもしれません。クレジットカードを落としたかもしれません。 与 “でしょう“ 相比，”かもしれません“表示的概率较低。 もしかしたら口语场合，用于可能性较低的场合，一般与 “～かもしれません“ “～ではありません“ 等呼应使用12345馬さんはまだ来ませんね。もしかしたら、今日は来ないかもしれませんよ。もしかしたら、太田さんではありませんか。ええ、そうですが。。 それで表示前面句子的时态为后面句子时态的原因、理由12日本に握手の習慣がないんですね。ええ、そうなんです。それで、つい握手するのを忘れます。 “だから” 也表示原因、理由。但是与 “それで” 相比，语气较强，且后面可以使表示其实活着推测的句子，而 “それで“不行1すぐに会議が始まします。だから、急いでください。 つい表示 并非有意 所为确形成了某种后果，并含有对意想不到的结果感到不快、后悔的语感。1バーゲン会場では、つい何でも買いたくなりです。 公司常用寒暄用语 句子 释义 申し訳ありません 对不起，抱歉 どうも 谢谢/对不起 ごめんください 对不起，有人吗 お邪魔します 打搅 お邪魔しました 打搅了 失礼します 打搅了/告辞了 失礼しました 告辞了/失礼了 お先に失礼します 先告辞了 お疲れ様でした 辛苦了 ご苦労様でした 辛苦了 これからお世話になります 今后请多多关照 いつもお世話になっております 承蒙多方照顾 いろいろお世話になりましたよ 收到更方面的照顾 お久しぶりです 好久不见 ご無沙汰しています 久疏问候 お大事に 请保重 おかげさまで 托您的福]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>初级下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file对象什么的]]></title>
    <url>%2F2017%2F07%2F24%2Ffile%2F</url>
    <content type="text"><![CDATA[fileList对象和file对象html5 中的 input[type=’file’] 的标签有 multiple 属性，允许用户选择多个文件，fileList 对象则是保存了这些文件的列表，列表每一项都是一个 file 对象 属性 name ：文件名 type ：文件类型。图片类型可通过image/开头关键字限制只允许上传图片 size ：文件大小 lastModified ：文件最后修改时间 input:file 对象中还存在一个 accept 属性，可以用来规定能够通过文件上传进行提交的文件类型。 accept=”image/*” 可以用来限制只允许上传图像格式。但是在 Webkit 浏览器下却出现了响应滞慢的问题，要等上好几秒才弹出文件选择框。解决方法就是将 ‘‘ 通配符改为指定的 *MIME 类型。 应用多文件FileList链接请戳 多文件FileList 12345678910111213&lt;input type="file" id="files" accept="image/gif,image/jpeg,image/jpg,image/png" multiple&gt;&lt;script&gt; var elem = document.getElementById('files'); elem.onchange = function (event) &#123; var files = event.target.files; for (var i = 0; i &lt; files.length; i++) &#123; // 文件类型为 image 并且文件大小小于 200kb if(files[i].type.indexOf('image/') &gt; -1 &amp;&amp; files[i].size &lt; 204800)&#123; console.log(files[i].name + files[i].type); &#125; &#125; &#125;&lt;/script&gt; 文件预览链接请戳 文件预览1234567891011121314151617&lt;input type=&quot;file&quot; id=&quot;files&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;&lt;img src=&quot;blank.gif&quot; id=&quot;preview&quot;&gt;&lt;script&gt; var elem = document.getElementById(&apos;files&apos;), img = document.getElementById(&apos;preview&apos;); elem.onchange = function () &#123; var files = elem.files, reader = new FileReader(); if(files &amp;&amp; files[0])&#123; reader.onload = function (ev) &#123; img.src = ev.target.result; &#125; reader.readAsDataURL(files[0]); &#125; &#125;&lt;/script&gt; Blob对象表示一个不可变，原始数据的类似文件对象。区别于 mysql 的 blob 类型（二进制容器），html5 中的 blob 对象除了可以存储二进制数据之外，还可设置数据的 mime 类型，从某种程度讲，实现了文件的存储。而 html5 中的 file 对象则是基于 blob 对象继承扩展而来。 构造函数1Blob(blobparts[,options]) 所以需要关键字 new 来声明，旧式的 BlobBuilder 方法已经过时，不在讨论。1234&lt;script&gt;var blob = new Blob(["Hello World!"],&#123;type:"text/plain"&#125;);console.log(blob)&lt;/script&gt; 属性 isClosed：bool 是否为关闭状态，关闭状态的 blob 对象不可读 size：数据大小 type：字符串，表明对象包含数据的数据类型 方法close()关闭 blob 对象，释放底层资源 slice([start[, end[, contentType]]])返回一个新的包含源 blob 对象指定数据的 blob 对象 用法适用类型数组和blob创建一个url123456var typeArray = GetTheTypedArraySomehow();//mimevar blob = new Blob([typeArray], &#123;type:'application/octet-binary'&#125;);// 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串// 你可以像使用一个普通URL那样使用它，比如用在img.src上。var url = URL.createObjectURL(blob); 事实上我并没得到这样的字符串，我觉得我可能被骗了。。 Blob中提取数据123456唯一方法是使用FileReadervar reader = new FileReader();reader.addEventListener("loadend", function() &#123; // reader.result contains the contents of blob as a typed array&#125;);reader.readAsArrayBuffer(blob); 使用 FileReader 以外的方法读取到的内容可能会是字符串或是数据 URL。123456789&lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); var blob = new Blob(['C:/Users/Administrator/Desktop/DC93J54VYAEKSLs.jpg'], &#123;type:'image/png'&#125;) canvas.toBlob(function(blob)&#123; console.log(blob) &#125;)&lt;/script&gt; 通过url下载文件window.URL对象可以为BLob对象生成一个网络地址，结合a标签的download属性可以实现url下载文件。123456789createDownload("download.txt","download file")function createDownload(fileName, content)&#123; var blob = new Blob([content]); var link = document.createElement("a"); link.innerHTML = fileName; link.download = fileName; link.href = URL.createObjectURL(blob); document.getElementsByTagName("body")[0].appendChild(link);&#125; 我们知道，img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。 Ps：就先写到这，剩下几个demo再说，感觉这个东西没这么简单。2017年7月24日22点27分]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img fail那点事]]></title>
    <url>%2F2017%2F07%2F18%2Fimg-fail%2F</url>
    <content type="text"><![CDATA[img fail前言：据说，一个公司的网速决定着一个程序员的心情与产出，而网速决定着一篇文章裂图的程度。 告别裂图html 中的 img 标签预设了几个关于自身加载的事件： onError 图片加载出现错误，多数的处理是将图片路径指向默认图片 onLoad 图片加载完成之后触发事件 onAbort 图片加载过程中，用户手动停止加载（浏览器停止按钮）触发事件 前面也讲过，图片加载缓慢乃至加载失败并不全因为是网速问题，还有可能是图片服务器延迟，或者图片过期请求失效等。然后就会出现所谓的“裂图”,而这时 img 标签的 alt 属性就会发挥作用，提示用户当前加载失败图像的信息。如图： 然后从运行下面代码可以在控制台看到图片加载几个事件相应的输出。 12345678910111213141516&lt;script&gt;function loadSuccess() &#123; console.log('image load success!');&#125;function loadError() &#123; console.log('image load error!');&#125;function loadAbort() &#123; console.log('image abort!');&#125;&lt;/script&gt;&lt;div class="img-container"&gt; &lt;img src="http://1234.com/1.jpg" onload="loadSuccess()" onerror="loadError()" onabort="loadAbort()" alt="this is a fail img" /&gt;&lt;/div&gt; 显然这样的表现形式，在用户看来是非常不优雅的。身为一个程序员，如果所有异常分支没有做相应处理，就相当于一辆急速行驶的汽车，保不齐啥时候刹车会失灵一下下。 动手吧利用加载失败时的标签和伪类 :before :after 来做点事我们可以通过 :before :after 来定义加载失败的提示信息，例如在图片上方提示加载失败提示，下方提示图片的源地址。1&lt;img src="http://oi2fsv5ls.bkt.clouddn.com/twitter/Cwc6jkVUcAExIOI.jpg-orgi" alt="gakki-twitter" class="img_load img_load1"&gt; 12345678910111213141516171819202122232425.img_load&#123; position: relative; display: block; width: 100%; height: auto; font-family: 'Helvetica'; font-weight: 300; line-height: 1.5; text-align: center;&#125;.img_load1:before&#123; display: block; margin-bottom: 10px; content: "image load error !";&#125;.img_load1:after &#123; display: block; width: 100%; font-size: 12px; white-space:nowrap; overflow:hidden; text-overflow: ellipsis; content: "[url: " attr(src) "]";&#125; 然后图片加载失败就会显示成如下： 优化一下(算是)虽然上例已经展示了比较优雅的错误提示，和相应的图片源地址，保证用户能接受且能通过源地址来进行更加合理的访问。但是，裂图依旧在！来让我们弄点东西遮起来吧。本例采用了 font-awesome 库来实现小图标展示,所以需要先引进css库12&lt;link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;img src="http://oi2fsv5ls.bkt.clouddn.com/twitter/CwvqJsEUkAAyeiG.jpg-orgi" alt="gakki-twitter" class="img_load img_load2"&gt; 1234567891011121314.img_load2:after&#123; position: absolute; z-index: 2; top: -1px; left: 0; display: block; width: 100%; height: 100%; font-size: 16px; font-family: FontAwesome; background-color: #fff; color: rgb(100, 100, 100); content: "\f1c5" " " attr(alt);&#125; 图示如下： 总结基本网站开发框架都会集成默认图片，而且过大的图片对于网站加载速度不友好，所以这个的应用场景大概也就是寄存图床之类图片过期的博客或者论坛了。 ps:实例中加载失败的后两张图片只需要在链接后面添加一个字母 n 就可以访问了，送一波图，顺便安利一下这是我老婆！]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式图片处理]]></title>
    <url>%2F2017%2F06%2F14%2FResponsive-Images%2F</url>
    <content type="text"><![CDATA[响应式图片处理 just note 固定宽度图像浏览器会根据设备像素比来选择加载图片 参数 srcset srcset 属性会罗列出当前可加载的备选图片，用逗号分隔。 不识别此属性的浏览器会直接加载 src 属性声明的图像。 x x 表示图像的设备像素比。 场景网站 logo 等宽度固定，大小不随着 viewport 的变化而变化 示例1234&lt;div class="img-box1"&gt; &lt;img srcset="images/gakki-540.jpg 1.5x,images/gakki-720.jpg 2x,images/gakki-1080.jpg 3x" src="images/gakki-360.jpg" alt="Responsive Images"&gt;&lt;/div&gt; 图片固定宽度为 300，浏览器通过识别设备像素比来筛选并加载图片。如上像素设备比为 2（例如：iphone6）的时候加载 gakki-720 的图片，3（iphone6 plus等）的时候会加载实际尺寸为 1080 的备选图。如果不支持，则默认加载 gakki-360。 点此 查看示例(建议新版本谷歌浏览) 可变宽度的图像浏览器会根据设备视窗大小( viewport )来选择加载图片 参数 srcset 备选图片列表，逗号分隔 sizes 包含两个值且用逗号分隔的图片展示规则列表，非必须。 如果 srcset 中使用了 w 描述符，则必须设置 sizes 属性。 第一个值为媒体查询条件，第二个为图片尺寸值，用 vw 来描述，不可使用百分比。 注：vw 兼容性不及 srcset 场景内容响应式图片处理 示例123456789&lt;div class=&quot;img-box2 &quot;&gt; &lt;img srcset=&quot;images/gakki-360.jpg 360w, images/gakki-540.jpg 540w, images/gakki-720.jpg 720w, images/gakki-1080.jpg 1080w&quot; sizes=&quot;(max-width: 400px) 100vw, (max-width: 960px) 75vw, 1080px&quot; src=&quot;images/gakki-1080.jpg&quot; alt=&quot;Responsive Images&quot;&gt;&lt;/div&gt; 浏览器会根据 sizes 定义的媒体查询条件来选择加载图片。例如网页宽度 600px 时，按照查询条件小于 960px,所以会按照 75% 加载，而 600*0.75 = 450 ,取最接近即 gakki-540 的图片。 点此 查看示例(建议新版本谷歌浏览) 不同的图像前两者都是通过 srcset 属性来实现同一图像不同质量的展示，而不支持此属性的浏览器会识别为普通的图像并加载 src 属性。 如果需要在不同的场景显示稍微不同的图片呢？例如大屏下显示全图，而小屏 or 移动端则仅需要展示细节，这样的场景需求则需要借用 picture 元素。 参数 source 定义媒体查询条件和备选图片地址 场景不同场景展示不同图片(全局细节之类的) 示例12345&lt;picture&gt; &lt;source media="(min-width: 960px)" srcset="images/gakki-large-1080.jpg"&gt; &lt;source media="(min-width: 575px)" srcset="images/gakki-mid-630.jpg"&gt; &lt;img src="images/gakki-small-360.jpg" class="picture-img" alt="Responsive Images"&gt;&lt;/picture&gt; 点此 查看示例(建议新版本谷歌浏览)浏览器窗口的变化可见，图片在小屏下显示裁剪版的细节图。 不同类型的图像针对不同浏览器支持类型，渲染相应的格式的图片。新格式的图像在图片质量以及图片大小方面表现良好，但是目前来讲，兼容性待考验。 参数 source 指定每个图像的MIME类型，浏览器会选择第一个含有其支持的MIME类型的源 源的顺序是至关重要的，如果浏览器无法识别所有的图象类型，它会回退至原来的 img 元素。 场景不同格式的图片在文件大小和图片质量表现不一 ，不少新格式表现良好。chrome 和 opera 浏览器支持 webp 格式图像，而 jpeg-xr 格式则是微软专有格式，仅 ie 支持。 示例123456&lt;picture&gt; &lt;source type="image/vnd.ms-photo" src="images/gakki-875.jxr"&gt; &lt;source type="image/jp2" src="images/gakki-875.jp2"&gt; &lt;source type="image/webp" src="images/gakki-875.webp"&gt; &lt;img src="images/gakki-875.jpg" class="picture-img" alt="Responsive Images"&gt;&lt;/picture&gt; 点此 查看示例(建议新版本谷歌浏览)ps：亲测，并没看到预料的结果，感觉被骗了.. 本文参考自 Using Responsive Images (Now).]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS webapp 踩屎记（二）]]></title>
    <url>%2F2017%2F05%2F23%2Fios-webapp-issues2%2F</url>
    <content type="text"><![CDATA[ios底部输入框遮挡 接上节，因为fixed元素的变现不友好，底部固定元素多采用了absolute定位。但底部固定元素内包含输入控件时，聚焦会发生输入框被键盘遮挡。 背景 场景 为了实现类 IM 即时通讯页面，输入框聚焦并紧贴键盘顶部浮起。 表现 某些浏览器会发生输入框遮挡被键盘遮挡。 qq内置以及微信内置浏览器估计对此作了些处理，基本没发现这种情况。 而别的浏览器，或多或少会复现这个问题（第一次触发） 理论上的表现为： 实际表现为： 分析输入框聚焦后，ios 和安卓对此作了不同的处理。安卓会对页面进行压缩，页面的 innerHeight 会发生变化，而ios会直接把页面向上推键盘的高度，页面的 innerHeight 并没发生变化（除了 UC 浏览器，真心不知道为什么这么另类）。查阅一些资料，发现了 Element 对象两个兼容性有待考量的方法 scrollIntoView() 和 scrollIntoViewIfNeeded()。 scrollIntoView() 让当前的元素滚动到浏览器窗口的可视区域内 语法 123element.scrollIntoView(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数 alignToTop 一个 Boolean 值： 如果为 true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为 false，元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions 一个 boolean 或一个带有选项的 object： 1234&#123; behavior: &quot;auto&quot; | &quot;instant&quot; | &quot;smooth&quot;, block: &quot;start&quot; | &quot;end&quot;,&#125; 如果是一个 boolean, true 相当于 {block: “start”}，false 相当于 {block: “end”} 兼容 详情点击 here. scrollIntoViewIfNeeded() 让当前的元素滚动到浏览器窗口的可视区域内 语法 12scrollIntoViewIfNeeded(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数 参数 alignToTop 一个 Boolean 值： 如果为 true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为 false，元素的底端将和其所在滚动区的可视区域的底端对齐。 兼容 详情点击 here. 然后，开始动刀，测试。 解决输入框聚焦，添加键盘呼起延迟，并对呼出键盘后的页面做输入框位置调整。 1234567891011121314151617181920212223242526272829var container = document.getElementById(&quot;wrapper&quot;); //最外部滚动容器var ele = document.getElementById(&quot;input_test&quot;);var eleDIv = document.getElementById(&quot;footer&quot;);var u = navigator.userAgent;var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端var isUc = u.indexOf(&quot;UCBro&quot;) &gt; -1;if(isiOS &amp;&amp; ele &amp;&amp; eleDIv)&#123; ele.onfocus = function()&#123; setTimeout(function()&#123; scrollDiv(); &#125;,isUc ? 350 : 200); &#125; &#125;function scrollDiv()&#123; var isChrome = u.indexOf(&quot;CriOS&quot;) &gt; -1; if(isChrome)&#123; document.body.scrollTop = container.clientHeight; //chrome 特殊处理 &#125;else if(Element.prototype.scrollIntoViewIfNeeded)&#123; eleDIv.scrollIntoViewIfNeeded(false); container.scrollTop = 1000; //切换输入法，首次等特殊情况补救 &#125;else if(Element.prototype.scrollIntoView)&#123; eleDIv.scrollIntoView(false); &#125;else&#123; document.body.scrollTop = container.clientHeight; //防止漏网之鱼 &#125;&#125; 吐槽： UC 两个方法都生效，不过呼出处理时间需要更久一点 chrome 也成功沦落到一个另类的表现，虽然自己公司 webapp 和谷歌表现一致 ios 原生 safari 浏览器的 UA 简直没法区分 Ps：这个方法可能不是最完美的解决方案，仅供参考，毕竟只是做个笔记。完整代码请点击。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS webapp 踩屎记（一）]]></title>
    <url>%2F2017%2F05%2F22%2Fios-webapp-issues1%2F</url>
    <content type="text"><![CDATA[底部 fixed 元素与输入控件的碰撞.. 移动端fixed元素背景过长的移动端网页需要底部固定一个按钮来方便引导用户操作 场景fixed 属性在 IOS 5版本开始支持，但是不如安卓表现良好。页面中同时存在输入控件（input、textarea）和 fixed 元素时，输入控件获取焦点呼出键盘，fixed 元素会错位。 安卓表现良好，输入控件聚焦，滚动页面fixed元素固定输入法顶部 IOS（仅以 safari、谷歌、UC 浏览器、微信 webview 作参考） safari、谷歌、微信，聚焦时 fixed 元素 fixed 属性失效，归于文档流底部 UC 浏览器聚焦，滚动页面 fixed 元素异位 输入框为失焦状态 输入框聚焦 滚动页面 解决输入控件聚焦，设置 fixed 元素 position 为 relative，回归文档流置于页面内容底部。失去焦点，reset 为 fixed 元素。1234567891011121314151617181920212223242526272829303132...&lt;body&gt; &lt;h2&gt;IOS fixed&lt;/h2&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p class="mt mb"&gt;&lt;input type="text" id="input_test" placeholder="input here"&gt;&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;p&gt;这是一个占位的段落.&lt;/p&gt; &lt;div id="footer"&gt;fixed div&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var o_input = document.getElementById('input_test'), o_footer = document.getElementById('footer'); o_input.onfocus = function()&#123; o_footer.style.position = 'relative'; &#125; o_input.onblur = function()&#123; o_footer.style.position = 'fixed'; &#125;&lt;/script&gt;解决后表现: 输入框为聚焦状态 输入框聚焦 至此，下一篇搞定底部输入框遮挡问题，轻点。]]></content>
      <categories>
        <category>webapp</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记二]]></title>
    <url>%2F2017%2F05%2F15%2FRegExp-note2%2F</url>
    <content type="text"><![CDATA[抽风的电脑，字怎么变成繁体了。主要为正则对象函数的应用。 正则对象创建创建RegExp对象实例 显式构造: new RegExp(“pattern”[, “flags”]) 或 new RegExp(/pattern/[, “flags”]) 隐式构造: /pattern/[flags] 参数 pattern 正则表达式 flags 标志匹配规则。例如 “g” 全局匹配，”i” 不区分大小写，”m” 多行匹配等，常用的为 “g” 和 “i”。 正则函数应用RegExp对象test() 描述 检索字符串的指定值 语法 1exp.test(str) 参数 exp 正则对象 str 要检索的字符串 返回值 返回值为布尔类型，成功匹配则为 true ，反之 false 。 示例 123//检索字符串内是否存在&quot;abc&quot;var exp = /abc/;&apos;abcda&apos;.test(exp); //true exec() 描述 检索字符串的指定值 语法 1exp.exec(str) 参数 exp 正则对象 str 要检索的字符串 返回值 返回值为匹配到的值。若无匹配，返回 null 。 注：如果指定标志 g，可多次执行 exec() 查找成功匹配，查找位置从上一次查找的 lasetIndex 开始。 示例 123456789101112//多次执行exec()var patt1=new RegExp("o","g");do&#123;result=patt1.exec("Hello world!");console.log(result);&#125;while (result!=null)// ["o", index: 4, input: "Hello world!"]// ["o", index: 7, input: "Hello world!"]// null compile()将来的版本会被移除 web 标准，不再赘述。 String对象match() 描述 当一个字符串与一个正则表达式匹配时，match() 方法检索匹配项。 语法 1str.match(exp) 参数 exp 正则对象 如果 exp 传入的值为非正则对象，则会隐示调用 new RegExp(exp) 方法转换成正则对象。 如果 exp 传入的值为空，则返回结果为 [‘’]。 str 要检索的字符串 返回值 array。 包括匹配结果以及子表达式捕获结果的数组。如果未匹配，返回 null。 如果正则对象未指定 “g” ,返回结果同 RegExp.exec() ，且返回结果中拥有两个属性： index: 搜索结果索引值，input: 匹配的原始字符串。 如果指定了 “g” ,返回结果为所有匹配结果字符串的数组对象，而不是RegExp对象，且捕获结果不可获得。 示例 search() 描述 search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。 语法 1str.search(exp) 参数 exp 正则对象 str 要检索的字符串 返回值 匹配成功返回首次匹配结果的索引，否则返回 -1 . 示例 1234var str = 'Today is Sun.!';var result = str.search(/(sun\.)/i); //返回匹配结果的索引值result // 9 split() 描述 字符串对象分割成字符串数组，字符串分割成子串。 语法 1str.split(separator[, limit]) 参数 separator 字符串或正则对象，指定字符串分割的位置 limit 指定返回数组的最大长度。如果设定了 limit 值，返回数组的最大长度不超过 limit，否则不计长度，全部返回。 返回值 一个字符串数组，但不包括 separator 本身。 如果 separator 为包含子表达式的正则对象，那么返回数组中包括子表达式匹配的字符串，但不包含与整个正则表达式匹配的字符串。 注： 函数功能同Array.join()相反。 如果 separator 指定为 “”,则每个字符都会被分割。 示例 1234var str = "hello world! let's rock it.";str.split(/(!|\.)\s/) //分割两句话，且包括子表达式匹配结果//["hello world", "!", "let's rock it."] replace() 描述 字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 语法 1str.replace(exp|substr, replacement) 参数 exp|substr 子字符串或要替换的正则对象。如果为字符串，则优先按照字符串匹配。 replacement 字符串值。指定替换文本或者生成替换文本的函数 返回值 一个新的匹配替换完成的字符串。 注： replace() 实现的是查找并替换。如果正则对象指定了 g（全局标志），则会依次查找替换所有匹配项，否则只会查找替换第一个匹配项。 此外 replacement 参数中还有一个特殊的 $ 的特定用法(见文章结尾)。 示例 12345678910111213141516171819//颠倒字符串var myName = 'yao, somnus';myName.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1") //$1 $2 匹配两个捕获的子表达式// 'somnus, yao'//引号的替换var testStr = '"Tom" and "jerry"';testStr.replace(/"([^"]*)"/g, "'$1'") //依次匹配并替换//'Tom' and 'jerry'//首字母大写转换var myName = 'yao, somnus';myName.replace(/\b(\w+)\b/g, function(name)&#123; return name.substring(0,1).toUpperCase()+name.substring(1); //通过生成替换文本函数完成文本替换&#125;)//Yao, Somnus 附：replace() 中 $ 的使用 语法 说明 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 正则表达式暂时就这么多了，笔记做完，心累，慢慢去撸demo了..]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记一]]></title>
    <url>%2F2017%2F05%2F15%2FRegExp-note1%2F</url>
    <content type="text"><![CDATA[心血來潮，又挖出正則表達式，順便整理下筆記。 元字符常用的元字符： 语法 说明 \b 匹配字边界 \B 匹配非字边界 \d 匹配数字字符 \D 匹配非数字字符 \w 匹配A-Z，a-z，0-9和下划线 \W 匹配除以上任意 特殊字符特殊字符的匹配需要进行转义，字符前添加 “\” 语法 说明 * 零次或多次匹配前面的字符或表达式 + 一次或多次匹配前面的字符或表达式 ? 零次或一次匹配。若紧随其他限定符则匹配非贪婪模式 ^ 匹配字符串开始的位置。若用作括号表达式第一个字符贼会对字符集取反 $ 匹配搜索字符串结尾的位置 . 匹配除换行符 \n 之外的任意单个字符 [ ] 标记括号表达式的开始和结尾 { } 限定表达式的开始和结尾 ( ) 子表达式的开始和结尾。可保存子表达式以备将来使用 &#124; 候选项表达式匹配 / JScript 中的文本正则表达式模式的开始和结尾，后一个 ‘/‘ 后添加单字符标志可指定搜索行为。g(全局) i(忽略大小写) \ 将下一字符标记为特殊字符文本。反向引用或八进制转义字符 非打印字符 语法 说明 \f 换页符 \n 换行符 \r 回车符 \v 垂直制表符 \t Tab 符 \s 任意空白字符 \S 任意非空白字符 贪婪与懒惰模式正则中包含能接受的重复的限定符时，通常行为是尽可能匹配更多的字符。 例如: a.*b 限定符在贪婪模式下会尽可能匹配更多的字符。a.*b 会匹配字符串 acbab 的 acbab 而不会匹配 acb。 有时我们需要匹配尽可能少的字符，这时我们需要在限定符后添加 ? 。例如：a.*?b 会匹配到 acbab 的 acb 和 ab 。 懒惰限定符: 语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 反向引用子表达式匹配的文本即此分组捕获的内容能在表达式以及程序中作进一步的处理。 子表达式用括号限定符来声明。 (a.b)c 中 (a.b) 则声明了一个子表达式，子表达式的内容可以捕获。而子表达式匹配的内容则可视作一个分组。 默认情况下，每个分组都拥有一个组号，从左到右，以子表达式的左括号为标志，第一组为1，依次递增。 反向引用用于重复搜索前面某个分组匹配的文本，语法为: +组号或组名 “\1” 。 例如：搜索不正确的变量声明 var var a = ‘hello’; \b(\w+)\b\s+\1\b 为例，(\w+) 分组匹配内容, \1 分组捕获内容。 或者可以自己指定组名 语法: (?&lt;name&gt;\w+) 或 (?’name’\w+) name 即为组名称。 反向引用这个组捕获内容，语法: \k&lt;name&gt; 所以上面的例子也可以写作: \b(?\w+)\b\s+\k\b 其次还有几种特殊用法: 分类 代码/语法 说明 内容捕获 (exp) 匹配exp并捕获到自动命名的组中 内容捕获 (?exp) 匹配exp并捕获到name命名的组中 内容捕获 (?:exp) 匹配exp不捕获也不分配组 零宽断言 (?=exp) 匹配exp前面位置 零宽断言 (?&lt;=exp) 匹配exp后面位置 零宽断言 (?!exp) 匹配后面不是exp的位置 零宽断言 (?&lt;!exp) 匹配钱面不是exp的位置 注释 (?#comment) 提供注释，方便阅读 零宽断言用于查找某些内容（但不包括自身）之前或者之后的东西，也就是说他们指定一个位置，而这个位置满足一定的条件（即断言），故称为零宽断言。 (?=exp) 零宽度正预测先行断言 断言自身出现的位置的后面能匹配表达式exp 例如： \b\w+(?=img\b) 匹配以img结尾的单词的前面部分(不包括 img ) (?&lt;=exp) 零宽度正回顾后发断言 断言自身出现的位置的前面能匹配表达式exp (?&lt;=\bexp)\w+\b 匹配 exp 开头的单词的后半部分(不包括 exp ) (?:exp) 零宽度负预测先行断言 断言此位置的后面不能匹配表达式 exp \d{3}(?:\d) 匹配后面不为数字的三位数 (?&lt;:exp) 零宽度负回顾后发断言 断言此位置出现的前面不能匹配子表达式 exp (?&lt;:0)\d{7} 匹配前面非 0 的 7 位数字 注释通过 (?#comment) 来包含注释，方便阅读。 优先级正则表达式的匹配优先级：从左到右，并遵循优先级顺序。从上到下优先级依次降低。 代码 说明 \ 转义符 () (?:) (?=) [] 括号，中括号 * + ? {n} {n,} {n,m} 限定符 ^ $ \任意字符 定位点和序列 &#124; 替换选项]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom使用心得以及插件推荐]]></title>
    <url>%2F2017%2F05%2F15%2Fatom%2F</url>
    <content type="text"><![CDATA[前言 公司移动化办公的原因，导致我不得不抛弃台式转战笔记本。而租来的笔记本4G的内存导致我在编辑器上的选择有些捉襟见肘。 家中台式编辑器一般都是使用 webstorm，精神洁癖的我每天就是自定义，修修改改。鉴于公司的笔记本，IDE 我觉得还是算了吧，一个 python 服务和一个 IDE，再加上一向吃内存就和喝水一样的谷歌浏览器，我已然已经预见了后果，唯有长按关机键才能拯救我。所以： 抛弃 IDE，不是因为功能不够强大，只是过于庞大 抛弃 sublime text，原因也有几点 package control 简直捉鸡，每次重装 貌似 都要重新安装一遍插件 某些插件有些捉鸡，例如常用插件 emmet 的 pyv8 error 不能自动识别当前编辑项目类型。我就编辑 Python 项目里的一个 js 文件，那些 angular、react 之类的插件你可以安分点嘛 此外 sublime text3 的函数定位功能简直良心，虽然这会增加内存消耗 然后刨到了 Atom，github 出品想来应该不差 体验正常流程的下载安装，略微有些不爽就是没让我选择安装选项，直接塞到了 C 盘。 settings 设置编码格式，字体字号，行高，softtab，快捷键之类，然后就是 package 的安装了。因为是 windows 平台，再加上个人有点懒，就直接 GUI 页面搜索安装了，如果你倾向于命令行模式，各个插件的说明里面都有注明。 注：插件的安装有时需要翻墙，最好还是挂起 vpn 然后一通 install。 插件推荐背景：windows7+Python+前端 仅此相关插件 工具相关 File Icons / File Icons 增加图标支持，虽然我不认为没有图标会影响开发体验，但是赏心悦目总不是坏事 git-plus / git-plus 提供编辑器内 git 支持，需要配置 git.exe 路径 使用方法：ctrl+shift+p 输入 git 命令 minimap / minimap sublime text 编辑器默认带的功能，快速定位代码？可能是的 platformio-ide-terminal / platformio-ide-terminal 编辑器中集成命令行（ windows 平台），linux 平台用着不习惯，搜索 terminal 就能收到 效果如图，可以自定义 Auto Run Command。service.bat 是自己写的启动 Python 项目的命令。 vim-mode-plus / vim-mode-plus vim 爱好者的福音，编辑器内支持 vim mode。 此外 chrome 插件里面也有一款类似的插件 Vimium，命令示意如下 sync-settings / sync-settings 重头戏，sublime 的我不知道如何做好配置等的备份，atom 的这个插件简直爽到不行不行的，备份同步一气呵成。 唯一需要注意的就是要做好 gistId 和 personalAccessToken 的配置。如果配置需要困难，移步here。 前端相关 emmet / emmet 一款非常强大的代码提示插件，一个 tab 教你做人。至于 emmet 的相关命令，有一张查询表，适用大部分规则。 autoprefixer / autoprefixer 自动添加兼容前缀插件，无需赘述。 js-hyperclick / js-hyperclick js声明跳转插件，据说要和hyperclick搭配使用。 jshint / jshint js 语法和风格的检查插件，帮助你规范编程习惯 Python相关不在赘述，单纯为了项目语言添加插件支持，名称显而易见。 autocomplete-python / autocomplete-python python-indent / python-indent python-tools / python-tools]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-start%2F</url>
    <content type="text"><![CDATA[脑子一热一抽筋把家里电脑换了个硬盘，重做了个系统.. 起因重装系统遇到阻碍，无奈格掉了硬盘，代之前的十几篇就随风而去了 解决还是原来的配方，不过已经变了味道。在原先的博客分支添加了一个hexo分支用作本地未编译代码的备份，而另一个master分支则用于博客编译文件的push分支。so，妈妈再也不担心我的代码因为各种原因丢失了。 待做趁着这次机会算是让我好好的了解了一下github ssh同步代码的流程。然后接下来就是单纯做个计划，计划下后来的几篇的内容。 github 入门使用指南（单就常用的吧） atom编辑器初尝心得与插件之类 git命令使用（公司办公一直GUI操作，总感觉自己是个假的git使用者） 内存管理，执行上下文，this，作用域作用域链，原型原型链之类（一直有再看，但是总感觉没入门，不能给别人讲清楚就算没懂吧） 整理一下正则表达式的笔记 等等最近日语学的整个人有点发懒，都五月份了才想起改该好好学习了，惭愧..]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES5新增数组方法]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-array-func-es5%2F</url>
    <content type="text"><![CDATA[ES5新增数组方法 ES5新增数组方法学习笔记。 Foreach接收一个函数作为参数，对数组进行循环遍历，而并不改变数组。 语法12345array.forEach(callback(currentValue, index, array)&#123;&#125;,this)array.forEach(callback[, thisArg]) 参数forEach方法会对数组的有效值的每一项执行callback函数，已经删除或者未初始化的项会被跳过。而callback函数会被传入三个参数： 数组当前项值 当前项的索引 数组对象本身 1234567891011121314151617var arr = ['a','b','c','d'];arr.forEach(console.log);//循环遍历功能等同于for(var i = 0; len = arr.length,i &lt; len; i++)&#123; console.log(arr[i]);&#125;//期望输出a 0 ["a", "b", "c", "d"]b 1 ["a", "b", "c", "d"]c 2 ["a", "b", "c", "d"]d 3 ["a", "b", "c", "d"]abcd 区别就在于forEach回调返回了三个参数，如图 而array.forEach(callback[, thisArg])方法中thisArg参数是可选的，如果指定则在执行回调时用作this的值，否则默认传入undefine。 兼容polyfill作为ES5新增方法，难免有些浏览器不支持，所以当我们使用时需要添加一段代码来帮助它兼容旧环境（polyfill）,代码来自MDN。123456789101112131415161718192021222324252627282930313233if (!Array.prototype.forEach) &#123; Array.prototype.forEach = function (callback,thisArg) &#123; var T, k; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; k = 0; while (k &lt; len) &#123; var kValue; if (k in O) &#123; kValue = O[k]; callback.call(T, kValue, k, O); &#125; k++; &#125; &#125;&#125; 注意forEach无法在所有有效元素传递给回调函数之前终止（而for循环有break方法），如需提前终止，需要把forEach置于try语句块中，并抛出异常。 Map用法同forEach基本相同，区别在于map方法返回一个新数组 语法1const new_array = arr.map(callback[, thisArg]) 参数略. 实例略. 兼容polyfill区别于forEach():123456789101112131415//创建新数组var A = new Array(len);...//保存callback返回值mappedValue = callback.call(T, kValue, k, O);// 返回值添加到新数组A中.A[ k ] = mappedValue;... //返回新数组Areturn A; Everyevery()接收一个返回值布尔类型的函数。 语法1arr.every(callback[, thisArg]) 参数every方法为数组的每一项执行callback函数，不会改变原数组。如果所有项callback函数返回为true，则方法返回true，如果遇到一个返回值为false，则直接终止并返回false。同样，callback方法只对那些有效值的项进行操作。callback被调用传入三个函数： 元素值 元素索引 数组对象本身 实例检测是否为奇数12345678function isOdd(ele, index, arr)&#123; return (ele % 2 == 1);&#125;var arr1 = [1,5,6,9,12].every(isOdd);//falsevar arr2 = [1,3,5,7,9,11].every(isOdd);//true 兼容polyfill1234567891011121314151617181920212223242526if (!Array.prototype.every)&#123; Array.prototype.every = function(callback, thisArg)&#123; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var T = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; var thisArg = arguments.length &gt; 1 ? thisArg : null; for (var i = 0; i &lt; len; i++) &#123; if (i in t &amp;&amp; !fun.call(thisArg, t[i], i, t)) return false; &#125; return true; &#125;;&#125; Some用法同every()基本相同，区别在于只要有一项callback函数返回值为true则方法返回true，否则为false。 语法1arr.some(callback[, thisArg]) 参数略. 实例略. 兼容polyfill略.区别只在于return值取反 reduce接受一个回调函数作为累加器，数组中每个值开始缩减，最终为一个值，是ES5中新增的一个数组逐项处理方法。reduce直译是缩减减少，函数定义以及实现个人感觉更像是递归。 语法1arr.reduce(callback[, initialValue]) 参数reduce方法接收一个函数类型的回调函数和一个可选初始值参数 callback 数组每一项的回调函数，接受4个参数 accumulator 上一次调用的返回值或者初始值 currentValue 正在处理的数组元素 currentindex 正在处理的数组元素索引 array 数组元素本身 initialValue 可选初始值参数，第一次调用传给accumulator 回调函数第一次执行时，有两种情况，如果initialValue指定，则accumulator取值为initialValue，currentValue取值数组第一项，如果没有指定initialValue，accumulator取值数组第一项，而currentValue取值数组第二项。 如果数组为空且没有提供initialValue，会抛出TypeError错误，如果仅有一个元素且没提供initialValue或者提供了initialValue数组为空，则直接返回，不会调用callback。 实例数组求和，数组扁平化，计算数组中值出现次数1234567891011121314151617181920212223242526272829//求和var arr = [1, 2, 3, 4];arr.reduce(function (pre, cur) &#123; return pre + cur;&#125;,10);//20//扁平化var newArr = [[1, 2], [3, 4], [5, 6]].reduce(function(pre, cur)&#123; return pre.concat(cur);&#125;,[]);//[1, 2, 3, 4, 5, 6]//计算重复值次数var arr = ['Alice', 'Bob', 'Ciel', 'Dianel', 'Alice', 'Ciel', 'Alice'];arr.reduce(function(newObj ,key)&#123; if(key in newObj)&#123; newObj[key]++; &#125;else&#123; newObj[key] = 1; &#125; return newObj;&#125;,&#123;&#125;);//&#123;Alice: 3, Bob: 1, Ciel: 2, Dianel: 1&#125; 兼容polyfill一如既往地代码来自MDN123456789101112131415161718192021222324252627282930313233343536373839if (!Array.prototype.reduce)&#123; Array.prototype.reduce = function(callback /*, initialValue*/) &#123; 'use strict'; if (this === null) &#123; throw new TypeError('Array.prototype.reduce called on null or undefined'); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = 0, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in t)) &#123; k++; &#125; if (k &gt;= len) &#123; throw new TypeError('Reduce of empty array with no initial value'); &#125; value = t[k++]; &#125; for (; k &lt; len; k++) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; Filter同every()方法类似，回调函数参数相同，返回值为回调参数结果为true的所有项集合的数组。 语法1arr.filter(callback[, thisArg]) 参数filter为数组中每一个有效值项调用callback函数，返回一个新数组，数组内容是callback返回值为true的元素的集合。 实例筛选奇数123456function isOdd(ele)&#123; return ele % 2 == 1;&#125;[1, 54, 23, 44, 13].filter(isOdd);//[1, 23, 13] 兼容polyfill123456789101112131415161718192021222324252627282930313233343536if (!Array.prototype.filter)&#123; Array.prototype.filter = function(fun /*, thisArg */) &#123; "use strict"; if (this === void 0 || this === null) throw new TypeError(); var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== "function") throw new TypeError(); var res = []; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t) &#123; var val = t[i]; // NOTE: Technically this should Object.defineProperty at // the next index, as push can be affected by // properties on Object.prototype and Array.prototype. // But that method's new, and collisions should be // rare, so use the more-compatible alternative. if (fun.call(thisArg, val, i, t)) res.push(val); &#125; &#125; return res; &#125;;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
</search>
