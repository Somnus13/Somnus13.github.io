<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-start%2F</url>
    <content type="text"><![CDATA[脑子一热一抽筋把家里电脑换了个硬盘，重做了个系统.. 起因重装系统遇到阻碍，无奈格掉了硬盘，代之前的十几篇就随风而去了 解决还是原来的配方，不过已经变了味道。在原先的博客分支添加了一个hexo分支用作本地未编译代码的备份，而另一个master分支则用于博客编译文件的push分支。so，妈妈再也不担心我的代码因为各种原因丢失了。 待做趁着这次机会算是让我好好的了解了一下github ssh同步代码的流程。然后接下来就是单纯做个计划，计划下后来的几篇的内容。 github 入门使用指南（单就常用的吧） atom编辑器初尝心得与插件之类 git命令使用（公司办公一直GUI操作，总感觉自己是个假的git使用者） 内存管理，执行上下文，this，作用域作用域链，原型原型链之类（一直有再看，但是总感觉没入门，不能给别人讲清楚就算没懂吧） 整理一下正则表达式的笔记 等等最近日语学的整个人有点发懒，都五月份了才想起改该好好学习了，惭愧..]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5新增数组方法]]></title>
    <url>%2F2017%2F05%2F06%2Fnew-array-func-es5%2F</url>
    <content type="text"><![CDATA[ES5新增数组方法 ES5新增数组方法学习笔记。 Foreach接收一个函数作为参数，对数组进行循环遍历，而并不改变数组。 语法12345array.forEach(callback(currentValue, index, array)&#123;&#125;,this)array.forEach(callback[, thisArg]) 参数forEach方法会对数组的有效值的每一项执行callback函数，已经删除或者未初始化的项会被跳过。而callback函数会被传入三个参数： 数组当前项值 当前项的索引 数组对象本身 1234567891011121314151617var arr = ['a','b','c','d'];arr.forEach(console.log);//循环遍历功能等同于for(var i = 0; len = arr.length,i &lt; len; i++)&#123; console.log(arr[i]);&#125;//期望输出a 0 ["a", "b", "c", "d"]b 1 ["a", "b", "c", "d"]c 2 ["a", "b", "c", "d"]d 3 ["a", "b", "c", "d"]abcd 区别就在于forEach回调返回了三个参数，如图 而array.forEach(callback[, thisArg])方法中thisArg参数是可选的，如果指定则在执行回调时用作this的值，否则默认传入undefine。 兼容polyfill作为ES5新增方法，难免有些浏览器不支持，所以当我们使用时需要添加一段代码来帮助它兼容旧环境（polyfill）,代码来自MDN。123456789101112131415161718192021222324252627282930313233if (!Array.prototype.forEach) &#123; Array.prototype.forEach = function (callback,thisArg) &#123; var T, k; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; k = 0; while (k &lt; len) &#123; var kValue; if (k in O) &#123; kValue = O[k]; callback.call(T, kValue, k, O); &#125; k++; &#125; &#125;&#125; 注意forEach无法在所有有效元素传递给回调函数之前终止（而for循环有break方法），如需提前终止，需要把forEach置于try语句块中，并抛出异常。 Map用法同forEach基本相同，区别在于map方法返回一个新数组 语法1const new_array = arr.map(callback[, thisArg]) 参数略. 实例略. 兼容polyfill区别于forEach():123456789101112131415//创建新数组var A = new Array(len);...//保存callback返回值mappedValue = callback.call(T, kValue, k, O);// 返回值添加到新数组A中.A[ k ] = mappedValue;... //返回新数组Areturn A; Everyevery()接收一个返回值布尔类型的函数。 语法1arr.every(callback[, thisArg]) 参数every方法为数组的每一项执行callback函数，不会改变原数组。如果所有项callback函数返回为true，则方法返回true，如果遇到一个返回值为false，则直接终止并返回false。同样，callback方法只对那些有效值的项进行操作。callback被调用传入三个函数： 元素值 元素索引 数组对象本身 实例检测是否为奇数12345678function isOdd(ele, index, arr)&#123; return (ele % 2 == 1);&#125;var arr1 = [1,5,6,9,12].every(isOdd);//falsevar arr2 = [1,3,5,7,9,11].every(isOdd);//true 兼容polyfill1234567891011121314151617181920212223242526if (!Array.prototype.every)&#123; Array.prototype.every = function(callback, thisArg)&#123; if(this == null)&#123; throw new TypeError('this is null or not defined'); &#125; var T = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof callback !== 'function') &#123; throw new TypeError(callback + 'is not a function'); &#125; var thisArg = arguments.length &gt; 1 ? thisArg : null; for (var i = 0; i &lt; len; i++) &#123; if (i in t &amp;&amp; !fun.call(thisArg, t[i], i, t)) return false; &#125; return true; &#125;;&#125; Some用法同every()基本相同，区别在于只要有一项callback函数返回值为true则方法返回true，否则为false。 语法1arr.some(callback[, thisArg]) 参数略. 实例略. 兼容polyfill略.区别只在于return值取反 reduce接受一个回调函数作为累加器，数组中每个值开始缩减，最终为一个值，是ES5中新增的一个数组逐项处理方法。reduce直译是缩减减少，函数定义以及实现个人感觉更像是递归。 语法1arr.reduce(callback[, initialValue]) 参数reduce方法接收一个函数类型的回调函数和一个可选初始值参数 callback 数组每一项的回调函数，接受4个参数 accumulator 上一次调用的返回值或者初始值 currentValue 正在处理的数组元素 currentindex 正在处理的数组元素索引 array 数组元素本身 initialValue 可选初始值参数，第一次调用传给accumulator 回调函数第一次执行时，有两种情况，如果initialValue指定，则accumulator取值为initialValue，currentValue取值数组第一项，如果没有指定initialValue，accumulator取值数组第一项，而currentValue取值数组第二项。 如果数组为空且没有提供initialValue，会抛出TypeError错误，如果仅有一个元素且没提供initialValue或者提供了initialValue数组为空，则直接返回，不会调用callback。 实例数组求和，数组扁平化，计算数组中值出现次数1234567891011121314151617181920212223242526272829//求和var arr = [1, 2, 3, 4];arr.reduce(function (pre, cur) &#123; return pre + cur;&#125;,10);//20//扁平化var newArr = [[1, 2], [3, 4], [5, 6]].reduce(function(pre, cur)&#123; return pre.concat(cur);&#125;,[]);//[1, 2, 3, 4, 5, 6]//计算重复值次数var arr = ['Alice', 'Bob', 'Ciel', 'Dianel', 'Alice', 'Ciel', 'Alice'];arr.reduce(function(newObj ,key)&#123; if(key in newObj)&#123; newObj[key]++; &#125;else&#123; newObj[key] = 1; &#125; return newObj;&#125;,&#123;&#125;);//&#123;Alice: 3, Bob: 1, Ciel: 2, Dianel: 1&#125; 兼容polyfill一如既往地代码来自MDN123456789101112131415161718192021222324252627282930313233343536373839if (!Array.prototype.reduce)&#123; Array.prototype.reduce = function(callback /*, initialValue*/) &#123; 'use strict'; if (this === null) &#123; throw new TypeError('Array.prototype.reduce called on null or undefined'); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = 0, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in t)) &#123; k++; &#125; if (k &gt;= len) &#123; throw new TypeError('Reduce of empty array with no initial value'); &#125; value = t[k++]; &#125; for (; k &lt; len; k++) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; Filter同every()方法类似，回调函数参数相同，返回值为回调参数结果为true的所有项集合的数组。 语法1arr.filter(callback[, thisArg]) 参数filter为数组中每一个有效值项调用callback函数，返回一个新数组，数组内容是callback返回值为true的元素的集合。 实例筛选奇数123456function isOdd(ele)&#123; return ele % 2 == 1;&#125;[1, 54, 23, 44, 13].filter(isOdd);//[1, 23, 13] 兼容polyfill123456789101112131415161718192021222324252627282930313233343536if (!Array.prototype.filter)&#123; Array.prototype.filter = function(fun /*, thisArg */) &#123; "use strict"; if (this === void 0 || this === null) throw new TypeError(); var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== "function") throw new TypeError(); var res = []; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t) &#123; var val = t[i]; // NOTE: Technically this should Object.defineProperty at // the next index, as push can be affected by // properties on Object.prototype and Array.prototype. // But that method's new, and collisions should be // rare, so use the more-compatible alternative. if (fun.call(thisArg, val, i, t)) res.push(val); &#125; &#125; return res; &#125;;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>